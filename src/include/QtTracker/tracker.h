/*
 * This file is part of LibQtTracker project
 *
 * Copyright (C) 2009, Nokia
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public License
 * along with this library; see the file COPYING.LIB.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA 02110-1301, USA.
 */
/*
 * qtracker.h
 *
 *  Created on: Jan 5, 2009
 *      Author: Iridian Kiiskinen <ext-iridian.kiiskinen at nokia.com>
 */



#ifndef SOPRANOLIVE_QTTRACKER_TRACKER_H
#define SOPRANOLIVE_QTTRACKER_TRACKER_H

#include "RDFService"
#include "tracker_common.h"

namespace SopranoLive
{
	namespace BackEnds
	{
		namespace Tracker
		{
			/*!
			 * 	\mainpage LibQtTracker Documentation
			 *
			 *	\section main_intro 1. Introduction
			 *
			 *	LibQtTracker is a client-side convenience library allowing for native Qt access to \ref Tracker::service_g "Tracker" by using DBus.
			 *	It offers a rich range of services on different layers of abstraction, exposing Tracker ontologies to the developers in an intuitive, native manner.
			 *	It is also a central gathering point of information on application side Tracker usage, and a central point of optimization where optimizations on tracker itself are unfeasible.
			 *	\n LibQtTracker offers a thin and direct SPARQL access layer, but in addition it offers a comprehensive set of Qt style services which hide the low level SPARQL.
			 *	These services include query building, remote RDF resource reflection, signaling and autogenerated convenience classes from all Tracker ontologies.
			 *	\n
			 *	\n
			 *	\section main_development 2. Development
			 *	\ref libqttracker_development "LibQtTracker development is ongoing", and a considerable amount of functionality \ref libqttracker_incomplete "is still missing".
			 *	\n
			 *	\n
			 *	\section main_user_manual 3. User manual
			 *	\ref user_manual "User manual"
			 *	\n
			 *	\n
			 *	\section main_structure 4. Structure
			 *
			 *	\subsection main_subprojects 4.1. LibQtTracker contains three subprojects:
			 *	4.1.1. \ref soprano : part of \ref soprano library functionality internalized.
			 *	\n 4.1.2. \ref soprano_live : an extension to Soprano functionality, offering \ref live_entities "live service interfaces" and more.
			 *	\n 4.1.3. \ref tracker_backend : a back-end implementation for SopranoLive interfaces, using the \ref Tracker::service_g through DBus.
			 *
			 *	The SopranoLive functionality is not dependent on Tracker as such, and in the future it might be detached as a separate, more generic project.
			 *	Currently however, Tracker \a is the only back-end for it.
			 *	Also, Tracker has only one, default, unnamed graph, even though the interfaces imply otherwise.
			 *	Thus when the documentation refers to "RDF service", "service", "RDF graph", "graph" and the like, these are all understood to be the same thing, and that they refer to the same, client side, \ref tracker_backend "tracker back-end", which is connected to the one \ref Tracker::service_g "tracker database".
			 *	\n
			 *	\n
			 *	\subsection main_layers 4.2. LibQtTracker offers its services on four different layers of abstraction:
			 *	The nexus between and within these layers, and to the back-end is \ref SopranoLive::RDFService object.
			 *	\ref tracker_backend offers an implementation for this, which is accessed through ::tracker().
			 *
			 *	4.2.1. \ref layer_raw for thin and direct SPARQL access
			 *	\n Provided for minimal overhead and explicit SPARQL access to the RDF service.
			 *
			 *	4.2.2. Base Service Layer
			 *	\n This layer offers most of the functionality, and is divided into two major subsections:
			 *	\n 4.2.2.1. \ref layer_bound allows accessing and manipulating properties and relationships of known RDF nodes.
			 *	\n 4.2.2.2. \ref layer_unbound allows for building of complex queries.
			 *
			 *	4.2.3. \ref layer_autogenerated for integrating domain specific ontologies into native Qt/C++
			 *	\n \ref tracker_ontologies
			 *
			 *	4.2.4. \ref layer_domain for assorted utilities
			 *	\n No domain specific functionality is introduced yet.
			 *
			 */

			/*! \defgroup tracker_backend Tracker back-end
			 * A back-end implementation for \ref SopranoLive interfaces, using the \ref Tracker::service_g service through DBus.
			 */

			/*! \page Tracker::service_g Tracker Service
			 *
			 * Tracker intro goes here
			 *
			 * \section tracker_ontologies Ontologies currently offered by Tracker
			 * See namespace listing.
			 */

			/*! \page layer_domain Domain Specific Helper Layer
			 * 	Birds singing in a sycamore tree while a goblin steals free from a catching spree.
			 */

			/*! \page libqttracker_development Active LibQtTracker development
			 *
			 * \section libqttracker_complete Recently completed functionality
			 * \arg Tracker browser utility: full browsing.
			 * \arg API feature with an inefficient but working implementation: full text search
			 * \arg Implementation for an existing API feature: filters in the query builder
			 * \arg API feature: efficient implementation for full text search (actually a Tracker-side development)
			 * \arg Improved documentation
			 *
			 * \section libqttracker_incomplete Incomplete functionality, of which:
			 *
			 * \subsection libqttracker_incomplete_active under active development:
			 * \arg Testing suites to find bugs
			 * \arg Reworking and reimplementing: signals
			 *
			 * \subsection libqttracker_incomplete_future near future development:
			 * \arg Implementation for an existing API feature: transactions
			 *
			 * \subsection libqttracker_incomplete_future far future development:
			 * \arg Other features not only useful to an individual project, but which could be imagined to be useful for at least one other team as well. However let me know even if you're unsure.
			 */


			/*!
			 * Delivers signals on updates of the associated RDF class inside Tracker.
			 * Each ClassUpdateSignaler object is owned by the thread local tracker singleton
			 * object. Once it is destroyed, no further signals will be emitted and pointers
			 * to ClassUpdateSignaler will become invalid.
			 * \sa \ref trackerRelease
			 */
			class Q_DECL_EXPORT ClassUpdateSignaler
				: public QObject
			{
				Q_OBJECT
			public:
				/*!
				 * \return the uri of the associated RDF class.
				 */
				virtual QUrl classUri() = 0;

				/*!
				 * Retrieve a singleton signaler object associated with the given rdf \a class_uri
				 * \return null if a signaler object could not be found or connected to properly.
				 * These might be because of DBus issues, or if the requested class doesn't have
				 *   tracker:notify = true
				 * set.
				 * Associates the signaler singleton with the thread tracker service object by
				 * implicitly invoking \ref tracker(). To free resources after no more signals
				 * are needed, \ref trackerRelase() should be called and all other references
				 * to the thread tracker service object should be released.
				 */
				static ClassUpdateSignaler *get(QUrl class_uri);

				//! \overload
					template<typename Type_>
				static ClassUpdateSignaler *get() { return get(Type_::iri()); }

				//! \overload
				static ClassUpdateSignaler *get(QString ontology_prefix, QString class_name);

			Q_SIGNALS:
				/*!
				 * Emitted when the associated RDF class is added as a rdf:type property
				 * to the given \a subjects set in Tracker.
				 */
				void subjectsAdded(const QStringList &subjects);
				//! DEPRECATED, search&replace typo here. Use subjectsRemoved.
				void baseRemoveSubjectsd(const QStringList &subjects);
				/*!
				 * Emitted when the associated RDF class is removed as rdf:type
				 * property to the given \a subjects set in Tracker.
				 */
				void subjectsRemoved(const QStringList &subjects);
				/*!
				 * Emitted when a property of the associated RDF class changes
				 * \param subjects the set of subjects with changes
				 * Specifically, for all inserted and deleted triples in Tracker,
				 * if the domain of the predicate is the associated class,
				 * the subject of the triple is signaled.
				 */
				void subjectsChanged(const QStringList &subjects);
				/*!
				 * Emitted when properties of the associated RDF class changes
				 * \param subjects the set of subjects with changes
				 * Specifically, for all inserted and deleted triples in Tracker,
				 * if the domain of the predicate is the associated class,
				 * the subject of the triple is signaled.
				 * \param props a limiting set of properties that have changed.
				 * This set of properties is shared across the subjects, and can
				 * contains false positive matches. The user has to further query
				 * which properties have actually changed and their resulting
				 * values for each subject.
				 */
				void subjectsChanged(const QStringList &subjects, const QStringList &props);
			};


			/*!
			 * \return a thread local service object for accessing Tracker. Each thread can
			 * have only one Tracker service object running at a given moment. If such service
			 * object exists, this function will return a reference to it, otherwise a new one
			 * is created. If all references to the returned service are released, it will be
			 * destroyed. It is advisable to store a reference to the backend somewhere for
			 * the duration of Tracker access. Due to thread locality, no state is shared
			 * across threads, including transaction information. If processing needs to be
			 * parallelized, the locking of resources must be handled manually.
			 * Note: listeners connected on ClassUpdateSignaler will not keep the Tracker
			 * service object alive.
			 */
			RDFServicePtr Q_DECL_EXPORT service();

			/*!
			 * \overload for \ref Tracker::service. Will store a shared pointer to the returned
			 * tracker cache object inside a persistent internal cache, causing it to live even
			 * if all external shares are released.
			 * \sa releaseTracker()
			 */
			RDFServicePtr Q_DECL_EXPORT tracker();

			/*!
			 * Clears the internal persistent tracker reference for this thread.
			 * After this call, the Tracker backend will be destroyed after
			 * last reference to is released, as if it had been created with
			 * \ref Tracker::service.
			 * \return the previous reference
			 */
			RDFServicePtr Q_DECL_EXPORT trackerRelease();

			/*! Enables processing of events when blocking on given \a tracker_service,
			 * passing given \a flags to QCoreApplication::processEvents. Note that
			 * asynchronous signal based approach is recommended as the standard approach,
			 * and you should use this approach only if no alternative exists.
			 */
			void Q_DECL_EXPORT enableProcessEventsOnBlock
					( RDFServicePtr const &tracker_service
					, QEventLoop::ProcessEventsFlags flags = QEventLoop::AllEvents);

			//! Disables processing of events when blocking on given \a tracker_service.
			//! \sa enableProcessEventsOnBlock
			void Q_DECL_EXPORT disableProcessEventsOnBlock(RDFServicePtr const &tracker_service);

			/*!
			 * Execute given batch sparql \a update query.
			 * If given \a service is null, tracker() is used.
			 * In Tracker, batch updates and regular updates go to different execution queues.
			 * Regular update query is also in the same queue that all queries are executed in.
			 * Thus the batch update queue should be used for large updates, to avoid blocking regular queries.
			 * You can also request for a batch update by directly calling
			 * ::tracker()->executeQuery(select, BatchMode);
			 */
			void Q_DECL_EXPORT dispatchBatchSparqlUpdate(RDFUpdate const &update);

			/*!
			 * Commit all possible pending batch queries in Tracker.
			 * Calling this function ensures that the batch queue is empty before
			 * executing any further select or update queries.
			 */
			void Q_DECL_EXPORT dispatchBatchCommit();

			typedef QMap<QString, QString> UpdateResultBlanksMap;
			typedef QVector<UpdateResultBlanksMap> UpdateResultSolutions;
			typedef QVector<UpdateResultSolutions> UpdateResultOperations;

			UpdateResultOperations Q_DECL_EXPORT sparqlUpdateBlank(const QString& query);

			/*!
			 * Initiate tracker database file fsync. Guarantees tracker data durability on all
			 * already committed data even in cases of ungraceful filesystem shutdown (typically
			 * in system crashes), but will cause a performance hit. Blocks until fsync is
			 * complete.
			 */
			void Q_DECL_EXPORT sync(bool block = true);

			/*!
			 * By default, 0 on release builds, 1 on debug builds.
			 */
			void Q_DECL_EXPORT setTrackerVerbosity(int level = 0);


			//! \return tracker timeout in milliseconds.
			int Q_DECL_EXPORT trackerDefaultTimeout();

			//! Sets tracker timeout in milliseconds. By default,
			//! -1, which means the default QDBus timeout
			//! (generally, 25 seconds).
			void Q_DECL_EXPORT setTrackerDefaultTimeout(int timeout = -1);
		}
	}
}
#endif // SOPRANOLIVE_QTTRACKER_TRACKER_H
