 /*
 * This file is part of LibQtTracker project
 *
 * Copyright (C) 2009, Nokia
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public License
 * along with this library; see the file COPYING.LIB.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA 02110-1301, USA.
 */
/*
 * liveresource.h
 *
 *  Created on: Jan 19, 2009
 *      Author: Iridian Kiiskinen <ext-iridian.kiiskinen at nokia.com>
 */

#ifndef SOPRANOLIVE_LIVERESOURCE_H_
#define SOPRANOLIVE_LIVERESOURCE_H_

#include <QtCore/QSharedPointer>
#include <QtCore/QStringList>
#include <QDateTime>
#include <QMap>
#include <QUrl>
#include <QDebug>
#include "livenode.h"
#include "rdfunbound.h"

namespace SopranoLive
{
/*!
 *	\page layer_bound Object Manipulation with Bound Services
 *
 *  Intro snippet from examples/email/email.cpp, EmailViewer::loadEmail:
 *	\code
LiveNodes recipients = email->getRecipients();
QStringList recipient_string;
foreach(Live<nco::Contact> contact, recipients.nodes())
	recipient_string << contact->getFullname();
 *	\endcode
 *
 *	The two core concepts of the bound section are \ref LiveResource and \ref LiveNodeModel, representing a single and a set of RDF resources and literals as by-reference, free store objects.
 *	They are most commonly manipulated with the by-value convenience smart pointer objects, \ref LiveNode and \ref LiveNodes.
 *	\n These are \ref live_entities "live entities".
 *	This means that changes to the these entities are readily and transparently reflected to the underlying RDF service entity, and conversely, changes happening on the RDF service are reflected back to the client.
 *	A lot of effort has been put into realising good performance, and the implementation is able to perform a considerable amount of optimizations at various stages to maintain high efficiency (at least, this will be the case. Currently very few optimizations are performed).
 *
 *	\section layer_bound_livenode LiveResource and LiveNode
 *	\ref LiveResource represents a live proxy to a single RDF node inside a specific service graph.
 *	Even though the value of the node can never change, the relationships between different nodes can and do change.
 *	\ref LiveResource has the by-value convenience smart pointer to it, \ref LiveNode, which is actually a typedef for \ref Node <\ref LiveResource>.
 *	It handles memory management, and adds the set of non-live operations with which the actual values of the RDF node can be easily managed.
 *	More specific interfaces can be used with \ref Node as well, and this indeed is the starting point of the \ref layer_autogenerated "convenience class autogeneration".
 *
 *	\section layer_bound_livenodemodel LiveNodeModel and LiveNodes
 *	Where the single remote RDF node, that the LiveResource proxies, has a permanent value and is all about relationships with other entities, \ref LiveNodeModel is the exact opposite.
 *	LiveNodeModel has no relationships to other objects to speak of, but is all about modeling a certain concept as a set of LiveNodes.
 *	And similarily, there is a convenient type to easily manage LiveNodeModel, the \ref LiveNodes, which is a typedef \ref LiveBag<\ref LiveNodeModel>.
 *	\sa \ref livenodemodelptr_how_and_why
 */

/*! \page livenodemodelptr_how_and_why How To Use LiveNodes With LiveNodeModel, and why
 *  OUTDATED DOC // TODO
 *	\ref LiveNodeModelPtr is a shared pointer to a LiveNodeModel and is the main storage object of LiveNodeModel objects.
 *	The LiveNodeModel is destructed only once the last LiveNodeModelPtr pointing to it is destructed.
 *	The actual LiveNodeModel * can be retrieved from it with data() member.
 *
 *	An example:
 *	\code
void MyClass::modelMySelect(Select const &my_select)
{
	my_class_member_model_ptr = ::tracker()->modelQuery(my_select);
	my_class_member_list_view.setModel(my_class_member_model_ptr.data());
	return; // good
}
 *	\endcode
 *	See how the model returned by modelQuery is stored into my_class_member_model_ptr, which is a member variable of MyClass.
 *	If you did not do that, but instead:
 *	\code
void MyClass::modelMySelect(Select const &my_select)
{
	LiveNodeModelPtr ptr = ::tracker()->modelQuery(my_select);
	my_class_member_list_view.setModel(ptr.data());
	return; // oops!
}
 *	\endcode
 *	Results might not be what you expected, as the list view is empty even though you know it shouldn't be!
 *	What happens is that once the function returns, ptr gets destroyed, and as it is the last reference to the model, the model also gets destroyed.
 *	Qt handles this case gracefully and doesn't crash, but the user ends up wondering why the my_member_list_view shows nothing.
 *	That is because the model got destroyed! Always store a reference to the model somewhere as long as you want the model to be alive.
 *
 *	\section livenodemodel_why Why do I need to hold a shared pointer into a LiveNodeModel?
 *	Why couldn't I just use the QObject services and set it to be owned by some other QObject?
 *	Actually, at some point, a front-end object for LiveNodeModel which behaves like this might be implemented.
 *	But currently, the chosen design of the live entities is that they \a proxy some external resource to act as much like a native object as possible.
 *	For better or worse, this means that a single LiveNodeModel might be shared by different parts of the same application.
 *	And ultimately this requires, as with LiveResource, that a LiveNodeModel be owned by the service. Clients are given some control over the lifetime with shared pointers to prevent premature destruction.
 *	Also because of this it is not in fact guaranteed that the LiveNodeModel gets destroyed once the last pointer the user holds to it is destroyed.
 *	The service might also keep a reference to it until some cleanup phase later on.
 *
 */

	/* TODO !
	 * Used to denote a specific type with run-time type information, using Qt metainformation infrastructure.
	 */
	// TODO wtf typedef QSharedPointer<Node> NodePtr;

	/*!
	 *	A live entity, the base interface to a specific rdf resource in a graph.
	 *	\n It offers a wide array of live methods and signals and acts as the main communication path between the client and a service.
	 *
	 *	Resource is implemented and returned to the user by the service of the graph the resource lives in.
	 *	The lifetime of the resource is handled by the service, but the user is offered a degree of control over them by shared pointers.
	 *	As long as client has at least one shared pointer referencing the Resource, it will not get destroyed.
	 *	See the Qt documentation for the QSharedPointer class for more information.
	 *	The majority of the time this handling is performed transparently through \ref Live object.
	 */
	class Q_DECL_EXPORT LiveResource
		: public QSharedFromThis<LiveResource, QObject>
	{
		Q_OBJECT

	public:
		//! \return encoded iri of this class
		static const char *encodedIri() { return "http://www.w3.org/2000/01/rdf-schema#Resource"; };
		//! \return iri of this class
		static QUrl const &iri() { static QUrl *ret = 0; if(!ret) ret = new QUrl(QUrl::fromEncoded(encodedIri(), QUrl::StrictMode)); return *ret; }
		//! The base classes of this class
		typedef Detail::EmptyBase BaseClasses;

		typedef Contexts::Generic DefiningContext;

        /*!
		 * Live blocking.
		 * \return a local representation of the proxied RDF node as \ref Node.
         */
		virtual Node const &node() const = 0;

		typedef RDFGraph GraphType;
        /*!
		 * \ref live_entities "Live non-blocking".
		 * \return the \ref RDFGraph this proxy belongs to
         */
		virtual GraphType *graph() const = 0;

		/*!
		 * \ref live_entities "Live blocking".
		 * \return \a RDFVariable representing this node
		 * \n Binding the variable to the \ref RDFGraph obtained
		 * with \ref graph of this node will evaluate to an alias of this node.
		 * \n Blocks only if the back-end implementation doesn't have source
		 * variable support and if this node has no local representation.
		 * In this case the node() is called and an RDFVariable is generated
		 * out of that.
		 */
		virtual RDFVariable sourceVariable() const = 0;

		/*!
		 * \ref live_entities "Live blocking".
		 * \return a \ref LiveNodes set corresponding to the rdf:type properties associated with this resource.
		 */
		LiveNodes types(RDFStrategyFlags strategy = RDFStrategy::DefaultStrategy) const
		{	return types(strategy, QSharedPointer<QObject>()); }

		//! \overload
		virtual LiveNodes types(RDFStrategyFlags strategy, QSharedPointer<QObject> const &parent) const = 0;

		/*!
		 * \ref live_entities "Live blocking".
		 * \return a live \ref LiveNodes set corresponding to the rdf:type properties associated with this resource.
		 */
		LiveNodes liveTypes(RDFStrategyFlags strategy = RDFStrategy::DefaultStrategy) const
		{ return types(strategy | LiveNodeModel::RequireLive); }

		//! \ref live_entities "Live blocking".
		//! \return true if the resource has given \a type; false otherwise
		bool hasType(LiveNode const &type) const;
		//! \overload
		bool hasType(LiveNode const &type, RDFStrategyFlags flags) const;

		//! \overload
			template<typename Type_>
		bool hasType(RDFStrategyFlags flags = RDFStrategyFlags()) const;

		//! \ref live_entities "Live blocking".
		//! \return the number of properties matching the given \a property_data
		virtual LiveNodes getProperties(RDFProperty const &property_data, RDFVariableList const &additional_columns = RDFVariableList()) const
		{
			RDFProperty prop(property_data);
			return implGetProperties(prop, additional_columns);
		}

		//! \ref live_entities "Live blocking".
		//! \return the number of properties matching the given \a property_data structure
		int baseHasProperties(RDFProperty const &property_data) const
		{
			RDFProperty prop(property_data);
			return implHasProperties(prop);
		}

		//! \ref live_entities "Live blocking".
		//! \return the number of properties matching the given \a property_data structure
		virtual int hasProperties(RDFProperty const &property_data) const
		{
			RDFProperty prop(property_data);
			return implHasProperties(prop);
		}

        /*!
		 * \ref live_entities "Live blocking".
		 * \return a static snapshot of objects determined by the given \a predicate and \a object_info constraints with this resource as subject.
		 * The returned model will not be updated of remote changes, and no writes on it will be relayed onwards.
		 * \param predicate is used to constrain the returned node set. Typically this is a single, explicit predicate uri.
		 * \param object_info is used to constrain the returned node set, but also to the declare internal type of the
		 * \param strategy determines the behaviour of the returned model. \sa RDFStrategyFlags
		 * \param parent shared parent of the returned model. \sa shared_parent
		 * \n Blocks if \a predicate or \a object have no local value and an incompatible source.
		 * \sa cacheProperties property_caching
         */
		LiveNodes baseGetObjects(RDFVariable const &predicate = RDFVariable(), RDFVariable const &object_info = RDFVariable(), RDFStrategyFlags strategy = RDFStrategy::DefaultStrategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{
			RDFProperty prop(RDFProperty::fromObjectOf(predicate, object_info, strategy, parent));
			return implGetProperties(prop);
		}
		//! \overload
		//! \param Predicate_ determines the predicate iri and internal object type
			template<typename Predicate_>
		LiveNodes baseGetObjects(RDFVariable object_info = RDFVariable(), RDFStrategyFlags strategy = RDFStrategy::DefaultStrategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{
			RDFProperty prop(RDFProperty::fromObjectOf<Predicate_>(object_info, strategy, parent));
			return implGetProperties(prop);
		}
		//! \overload
		//! \param Predicate_ determine the predicate iri and internal object type
			template<typename Predicate_>
		LiveNodes baseGetObjects(RDFStrategyFlags strategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{
			RDFProperty prop(RDFProperty::fromObjectOf<Predicate_>(RDFVariable(), strategy, parent));
			return implGetProperties(prop);
		}

		LiveNodes getObjects(RDFVariable const &predicate = RDFVariable(), RDFVariable const &object_info = RDFVariable(), RDFStrategyFlags strategy = RDFStrategy::DefaultStrategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{
			RDFProperty prop(RDFProperty::fromObjectOf(predicate, object_info, strategy, parent));
			return implGetProperties(prop);
		}
			template<typename Predicate_>
		LiveNodes getObjects(RDFVariable object_info = RDFVariable(), RDFStrategyFlags strategy = RDFStrategy::DefaultStrategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{
			RDFProperty prop(RDFProperty::fromObjectOf<Predicate_>(object_info, strategy, parent));
			return implGetProperties(prop);
		}
			template<typename Predicate_>
		LiveNodes getObjects(RDFStrategyFlags strategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{
			RDFProperty prop(RDFProperty::fromObjectOf<Predicate_>(RDFVariable(), strategy, parent));

			return implGetProperties(prop);
		}

        /*!
		 * \ref live_entities "Live blocking".
		 * \param object_type used to construct a new object if one does not already exist.
		 * \return the first object of this node with given \a predicate.
		 * The 'first object' is consistently the same one until the object set changes.
		 * If none exist, a null LiveNode is returned.
		 * \n Blocks only if \a predicate has no local value and an incompatible source.
         */
		LiveNode baseFirstObject(LiveNode const &predicate, CppType object_type = CppType()) const { return firstObject(predicate, object_type); }
		//! \overload
		//! \param Predicate_ determines the predicate iri and internal object type
		//! \return the first object if one exists; default constructed value otherwise
			template<typename Predicate_>
		typename AutoGen::Property<Predicate_>::Type baseFirstObject() const;

		virtual LiveNode firstObject(LiveNode const &predicate, CppType object_type = CppType()) const = 0;
			template<typename Predicate_>
		LiveNode firstObject() const { return firstObject(Predicate_::iri(), CppType::of<typename Predicate_::Range>()); }

        /*!
		 * \ref live_entities "Live blocking".
		 * \return the live model representing the objects constrained by the given \a predicate and \a _info constraints with this resource as subject.
		 * Local writes and remote updates are properly transferred remotely and locally respectively.
		 * \param predicate is used to constrain the returned node set. Typically this is a single, explicit predicate URI.
		 * \param object_info is used to constrain the returned node set, but also to the declare internal type of the
		 * \param strategy determines the behaviour of the returned model. \sa RDFStrategyFlags
		 * \param parent shared parent of the returned model. \sa shared_parent
		 * \n Blocks if \a predicate or \a object have no local value and an incompatible source.
		 * \sa cacheProperties property_caching
         */
		LiveNodes baseLiveObjects(RDFVariable const &predicate = RDFVariable(), RDFVariable const &object_info = RDFVariable(), RDFStrategyFlags strategy = RDFStrategy::DefaultStrategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{
			RDFProperty prop(RDFProperty::fromObjectOf(predicate, object_info, strategy | LiveNodeModel::RequireLive, parent));
			return implGetProperties(prop);
		}
		LiveNodes liveObjects(RDFVariable const &predicate = RDFVariable(), RDFVariable const &object_info = RDFVariable(), RDFStrategyFlags strategy = RDFStrategy::DefaultStrategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{
			RDFProperty prop(RDFProperty::fromObjectOf(predicate, object_info, strategy | LiveNodeModel::RequireLive, parent));
			return implGetProperties(prop);
		}

        /*!
         * \overload
		 * \param Predicate_ determine the predicate IRI and internal object type
         */
			template<typename Predicate_>
		LiveNodes baseLiveObjects(RDFVariable object_info = RDFVariable(), RDFStrategyFlags strategy = RDFStrategy::DefaultStrategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{
			RDFProperty prop(RDFProperty::fromObjectOf<Predicate_>(object_info, strategy | LiveNodeModel::RequireLive, parent));
			return implGetProperties(prop);
		}
			template<typename Predicate_>
		LiveNodes liveObjects(RDFVariable object_info = RDFVariable(), RDFStrategyFlags strategy = RDFStrategy::DefaultStrategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{
			RDFProperty prop(RDFProperty::fromObjectOf<Predicate_>(object_info, strategy | LiveNodeModel::RequireLive, parent));
			return implGetProperties(prop);
		}

        /*!
         * \overload
		 * \param Predicate_ determine the predicate IRI and internal object type
         */
			template<typename Predicate_>
		LiveNodes baseLiveObjects(RDFStrategyFlags strategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{
			RDFProperty prop(RDFProperty::fromObjectOf<Predicate_>(RDFVariable(), strategy | LiveNodeModel::RequireLive, parent));
			return implGetProperties(prop);
		}
			template<typename Predicate_>
		LiveNodes liveObjects(RDFStrategyFlags strategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{
			RDFProperty prop(RDFProperty::fromObjectOf<Predicate_>(RDFVariable(), strategy | LiveNodeModel::RequireLive, parent));
			return implGetProperties(prop);
		}

        /*!
		 * \ref live_entities "Live blocking".
		 * \param object_type used to construct a new object if one does not already exist.
		 * \return an object of this node with given \a predicate.
		 * If there are many, consistently 'first one' is returned.
		 * The only guarantee is that for any given set of objects,
		 * the 'first object' is always the same one.
		 * If none exist, a new one is constructed, set and returned.
		 * \n Blocks only if \a predicate has no local value and an incompatible source.
         */
		LiveNode baseGetObject(LiveNode const &predicate, CppType object_type = CppType()) const { return getObject(predicate, object_type); }

		//! \overload
		//! \param Predicate_ determines the predicate iri and internal object type
			template<typename Predicate_>
		typename AutoGen::Property<Predicate_>::Type baseGetObject() const;

		virtual LiveNode getObject(LiveNode const &predicate, CppType object_type = CppType()) const = 0;

			template<typename Predicate_>
		LiveNode getObject() const { return getObject(Predicate_::iri(), CppType::of<typename Predicate_::Range>()); }

        /*!
		 * \ref live_entities "Live blocking".
		 * \param predicate used when setting the objects
		 * \param objects the set of objects to replace the current nodes
		 * \n Blocks only if \a predicate has no local value and an incompatible source or
		 * if \a objects has no local value and an incompatible source.
         */
		void baseSetObjects(LiveNode const &predicate, LiveNodes const &objects) const { return setObjects(predicate, objects); }
		virtual void setObjects(LiveNode const &predicate, LiveNodes const &objects) const = 0;

        /*!
		 * \ref live_entities "Live blocking".
		 * \param predicate used when setting the object
		 * \param objects the object to replace the current node(s)
		 * \n Blocks only if \a predicate has no local value and an incompatible source or
		 * if \a object has no local value and an incompatible source.
         */
		LiveNode baseSetObject(LiveNode const &predicate, LiveNode const &object) const { return setObject(predicate, object); }

		//! \overload
		//! \param Predicate_ determines the predicate iri and internal object type
			template<typename Predicate_>
		typename AutoGen::Property<Predicate_>::Type baseSetObject
				( typename AutoGen::Property<Predicate_>::Type const &object) const;

		virtual LiveNode setObject(LiveNode const &predicate, LiveNode const &object) const = 0;

			template<typename Predicate_>
		LiveNode setObject(LiveNode const &object) { return setObject(Predicate_::iri(), object); }

        /*!
		 * \ref live_entities "Live blocking".
		 * \param predicate used when adding the object
		 * \param object the object to add to the current nodes
		 * \return the node that was just set
		 * If the cardinality is restricted, might override previous values.
		 * \n Blocks only if \a predicate has no local value and an incompatible source or
		 * if \a object has no local value and an incompatible source.
         */
		LiveNode baseAddObject(LiveNode const &predicate, LiveNode const &object) const { return addObject(predicate, object); }

		//! \overload
		//! \param Predicate_ determines the predicate iri and internal object type
			template<typename Predicate_>
		typename AutoGen::Property<Predicate_>::Type baseAddObject
				( typename AutoGen::Property<Predicate_>::Type const &object) const;

		virtual LiveNode addObject(LiveNode const &predicate, LiveNode const &object) const = 0;

			template<typename Predicate_>
		LiveNode addObject(LiveNode const &object) { return addObject(Predicate_::iri(), object); }

        /*!
		 * \ref live_entities "Live blocking".
		 * \param predicate used when adding the object
		 * \param object_type the type of object that will created and added
		 * \return the node that was created and added
		 * If the cardinality is restricted, might override previous values.
		 * \n Blocks only if \a predicate has no local value and an incompatible source.
         */
		LiveNode baseAddObject(LiveNode const &predicate, CppType object_type) const { return addObject(predicate, object_type); }

		//! \overload
		//! \param Predicate_ determines the predicate iri and internal object type
			template<typename Predicate_>
		typename AutoGen::Property<Predicate_>::Type baseAddObject() const;

		virtual LiveNode addObject(LiveNode const &predicate, CppType object_type) const = 0;

			template<typename Predicate_>
		LiveNode addObject() { return addObject(Predicate_::iri(), CppType::of<typename Predicate_::Range>()); }

        /*!
		 * \ref live_entities "Live non-blocking".
		 * \param predicate used when removing the object.
		 * If blank or empty, the given \a object is removed from all properties from this node.
		 * \param object the object that will be removed
		 * If blank or empty, all objects with the given \a predicate are removed from this node.
		 * \n If both \a predicate and \a object are blank or empty, all triples in the graph where this node appears as a subject are removed.
		 * \n Caution is advised with this usage, as all third party properties will be removed as well.
		 * \n \ref removeInterface method offers a more refined mechanism for removing associations.
		 * \n Blocks only if \a predicate has no local value and an incompatible source or
		 * if \a object has no local value and an incompatible source.
         */
		void baseRemoveObject(LiveNode const &predicate, LiveNode const &object) const { return removeObject(predicate, object); }
		virtual void removeObject(LiveNode const &predicate, LiveNode const &object) const = 0;

			template<typename Predicate_>
		void baseRemoveObject( typename AutoGen::Property<Predicate_>::Type const &object) const
		{ removeObject(Predicate_::iri(), AutoGen::Property<Predicate_>::toNode(object)); }

        /*!
		 * \ref live_entities "Live blocking".
		 * Removes the objects constrained by given \a predicate and \a object with this node as the subject.
		 * \n Blocks only if \a predicate or \a object has no local value and an incompatible source.
		 * \sa property_caching
         */
		void baseRemoveObjects(RDFVariable const &predicate = RDFVariable(), RDFVariable const &object = RDFVariable()) const { return removeObjects(predicate, object); }
		//! \overload
			template<typename Property_>
		void baseRemoveObjects(RDFVariable const &object = RDFVariable()) const
		{ removeObjects(Property_::iri(), object); }

		virtual void removeObjects(RDFVariable const &predicate = RDFVariable(), RDFVariable const &object = RDFVariable()) const = 0;

			template<typename Property_>
		void removeObjects(RDFVariable const &object = RDFVariable()) const
		{ removeObjects(Property_::iri(), object); }

        /*!
		 * Emitted when a given \a object was added to the given \a predicate set of this node
         */
		Q_SIGNAL void objectAdded(LiveNode const &predicate, LiveNode const &object) const;
        /*!
		 * Emitted when a given \a object was removed from the given \a predicate of set this node
         */
		Q_SIGNAL void objectRemoved(LiveNode const &predicate, LiveNode const &object) const;



        /*!
		 * \ref live_entities "Live blocking".
		 * \return a static snapshot of subjects determined by the given \a predicate and \a subject_info constraints with this resource as subject.
		 * The returned model will not be updated of remote changes, and no writes on it will be relayed onwards.
		 * \param predicate is used to constrain the returned node set. Typically this is a single, explicit predicate uri.
		 * \param subject_info is used to constrain the returned node set, but also to the declare internal type of the
		 * \param strategy determines the behaviour of the returned model. \sa RDFStrategyFlags
		 * \param parent shared parent of the returned model. \sa shared_parent
		 * \n Blocks if \a predicate or \a subject have no local value and an incompatible source.
		 * \sa cacheProperties property_caching
         */
		LiveNodes baseGetSubjects(RDFVariable const &predicate = RDFVariable(), RDFVariable const &subject_info = RDFVariable(), RDFStrategyFlags strategy = RDFStrategy::DefaultStrategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{
			RDFProperty prop(RDFProperty::fromSubjectOf(predicate, subject_info, strategy, parent));
			return implGetProperties(prop);
		}
		//! \overload
		//! \param Predicate_ determines the predicate iri and internal subject type
			template<typename Predicate_>
		LiveNodes baseGetSubjects(RDFVariable subject_info = RDFVariable(), RDFStrategyFlags strategy = RDFStrategy::DefaultStrategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{
			RDFProperty prop(RDFProperty::fromSubjectOf<Predicate_>(subject_info, strategy, parent));
			return implGetProperties(prop);
		}
		//! \overload
		//! \param Predicate_ determine the predicate iri and internal subject type
			template<typename Predicate_>
		LiveNodes baseGetSubjects(RDFStrategyFlags strategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{
			RDFProperty prop(RDFProperty::fromSubjectOf<Predicate_>(RDFVariable(), strategy, parent));
			return implGetProperties(prop);
		}

		LiveNodes getSubjects(RDFVariable const &predicate = RDFVariable(), RDFVariable const &subject_info = RDFVariable(), RDFStrategyFlags strategy = RDFStrategy::DefaultStrategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{
			RDFProperty prop(RDFProperty::fromSubjectOf(predicate, subject_info, strategy, parent));
			return implGetProperties(prop);
		}
			template<typename Predicate_>
		LiveNodes getSubjects(RDFVariable subject_info = RDFVariable(), RDFStrategyFlags strategy = RDFStrategy::DefaultStrategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{
			RDFProperty prop(RDFProperty::fromSubjectOf<Predicate_>(subject_info, strategy, parent));
			return implGetProperties(prop);
		}
			template<typename Predicate_>
		LiveNodes getSubjects(RDFStrategyFlags strategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{
			RDFProperty prop(RDFProperty::fromSubjectOf<Predicate_>(RDFVariable(), strategy, parent));

			return implGetProperties(prop);
		}

        /*!
		 * \ref live_entities "Live blocking".
		 * \param subject_type used to construct a new subject if one does not already exist.
		 * \return the first subject of this node with given \a predicate.
		 * The 'first subject' is consistently the same one until the subject set changes.
		 * If none exist, a null LiveNode is returned.
		 * \n Blocks only if \a predicate has no local value and an incompatible source.
         */
		LiveNode baseFirstSubject(LiveNode const &predicate, CppType subject_type = CppType()) const { return firstSubject(predicate, subject_type); }
		//! \overload
		//! \param Predicate_ determines the predicate iri and internal subject type
		//! \return the first subject if one exists; default constructed value otherwise
			template<typename Predicate_>
		typename AutoGen::Property<Predicate_>::Type baseFirstSubject() const;

		virtual LiveNode firstSubject(LiveNode const &predicate, CppType subject_type = CppType()) const = 0;
			template<typename Predicate_>
		LiveNode firstSubject() const { return firstSubject(Predicate_::iri(), CppType::of<typename Predicate_::Range>()); }

        /*!
		 * \ref live_entities "Live blocking".
		 * \return the live model representing the subjects constrained by the given \a predicate and \a _info constraints with this resource as subject.
		 * Local writes and remote updates are properly transferred remotely and locally respectively.
		 * \param predicate is used to constrain the returned node set. Typically this is a single, explicit predicate URI.
		 * \param subject_info is used to constrain the returned node set, but also to the declare internal type of the
		 * \param strategy determines the behaviour of the returned model. \sa RDFStrategyFlags
		 * \param parent shared parent of the returned model. \sa shared_parent
		 * \n Blocks if \a predicate or \a subject have no local value and an incompatible source.
		 * \sa cacheProperties property_caching
         */
		LiveNodes baseLiveSubjects(RDFVariable const &predicate = RDFVariable(), RDFVariable const &subject_info = RDFVariable(), RDFStrategyFlags strategy = RDFStrategy::DefaultStrategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{
			RDFProperty prop(RDFProperty::fromSubjectOf(predicate, subject_info, strategy | LiveNodeModel::RequireLive, parent));
			return implGetProperties(prop);
		}
		LiveNodes liveSubjects(RDFVariable const &predicate = RDFVariable(), RDFVariable const &subject_info = RDFVariable(), RDFStrategyFlags strategy = RDFStrategy::DefaultStrategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{
			RDFProperty prop(RDFProperty::fromSubjectOf(predicate, subject_info, strategy | LiveNodeModel::RequireLive, parent));
			return implGetProperties(prop);
		}

        /*!
         * \overload
		 * \param Predicate_ determine the predicate IRI and internal subject type
         */
			template<typename Predicate_>
		LiveNodes baseLiveSubjects(RDFVariable subject_info = RDFVariable(), RDFStrategyFlags strategy = RDFStrategy::DefaultStrategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{
			RDFProperty prop(RDFProperty::fromSubjectOf<Predicate_>(subject_info, strategy | LiveNodeModel::RequireLive, parent));
			return implGetProperties(prop);
		}
			template<typename Predicate_>
		LiveNodes liveSubjects(RDFVariable subject_info = RDFVariable(), RDFStrategyFlags strategy = RDFStrategy::DefaultStrategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{
			RDFProperty prop(RDFProperty::fromSubjectOf<Predicate_>(subject_info, strategy | LiveNodeModel::RequireLive, parent));
			return implGetProperties(prop);
		}

        /*!
         * \overload
		 * \param Predicate_ determine the predicate IRI and internal subject type
         */
			template<typename Predicate_>
		LiveNodes baseLiveSubjects(RDFStrategyFlags strategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{
			RDFProperty prop(RDFProperty::fromSubjectOf<Predicate_>(RDFVariable(), strategy | LiveNodeModel::RequireLive, parent));
			return implGetProperties(prop);
		}
			template<typename Predicate_>
		LiveNodes liveSubjects(RDFStrategyFlags strategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{
			RDFProperty prop(RDFProperty::fromSubjectOf<Predicate_>(RDFVariable(), strategy | LiveNodeModel::RequireLive, parent));
			return implGetProperties(prop);
		}

        /*!
		 * \ref live_entities "Live blocking".
		 * \param subject_type used to construct a new subject if one does not already exist.
		 * \return an subject of this node with given \a predicate.
		 * If there are many, consistently the 'first one' is returned.
		 * The only guarantee is that for any given set of subjects,
		 * the 'first subject' is always the same one.
		 * If none exist, a new one is constructed, set and returned.
		 * \n Blocks only if \a predicate has no local value and an incompatible source.
         */
		LiveNode baseGetSubject(LiveNode const &predicate, CppType subject_type = CppType()) const { return getSubject(predicate, subject_type); }

		//! \overload
		//! \param Predicate_ determines the predicate iri and internal subject type
			template<typename Predicate_>
		typename AutoGen::Property<Predicate_>::Type baseGetSubject() const;

		virtual LiveNode getSubject(LiveNode const &predicate, CppType subject_type = CppType()) const = 0;

			template<typename Predicate_>
		LiveNode getSubject() const { return getSubject(Predicate_::iri(), CppType::of<typename Predicate_::Range>()); }

        /*!
		 * \ref live_entities "Live blocking".
		 * \param predicate used when setting the subjects
		 * \param subjects the set of subjects to replace the current nodes
		 * \n Blocks only if \a predicate has no local value and an incompatible source or
		 * if \a subjects has no local value and an incompatible source.
         */
		void baseSetSubjects(LiveNode const &predicate, LiveNodes const &subjects) const { return setSubjects(predicate, subjects); }
		virtual void setSubjects(LiveNode const &predicate, LiveNodes const &subjects) const = 0;

        /*!
		 * \ref live_entities "Live blocking".
		 * \param predicate used when setting the subject
		 * \param subjects the subject to replace the current node(s)
		 * \n Blocks only if \a predicate has no local value and an incompatible source or
		 * if \a subject has no local value and an incompatible source.
         */
		LiveNode baseSetSubject(LiveNode const &predicate, LiveNode const &subject) const { return setSubject(predicate, subject); }

		//! \overload
		//! \param Predicate_ determines the predicate iri and internal subject type
			template<typename Predicate_>
		typename AutoGen::Property<Predicate_>::Type baseSetSubject
				( typename AutoGen::Property<Predicate_>::Type const &subject) const;

		virtual LiveNode setSubject(LiveNode const &predicate, LiveNode const &subject) const = 0;

			template<typename Predicate_>
		LiveNode setSubject(LiveNode const &subject) { return setSubject(Predicate_::iri(), subject); }

        /*!
		 * \ref live_entities "Live blocking".
		 * \param predicate used when adding the subject
		 * \param subject the subject to add to the current nodes
		 * \return the node that was just set
		 * If the cardinality is restricted, might override previous values.
		 * \n Blocks only if \a predicate has no local value and an incompatible source or
		 * if \a subject has no local value and an incompatible source.
         */
		LiveNode baseAddSubject(LiveNode const &predicate, LiveNode const &subject) const { return addSubject(predicate, subject); }

		//! \overload
		//! \param Predicate_ determines the predicate iri and internal subject type
			template<typename Predicate_>
		typename AutoGen::Property<Predicate_>::Type baseAddSubject
				( typename AutoGen::Property<Predicate_>::Type const &subject) const;

		virtual LiveNode addSubject(LiveNode const &predicate, LiveNode const &subject) const = 0;

			template<typename Predicate_>
		LiveNode addSubject(LiveNode const &subject) { return addSubject(Predicate_::iri(), subject); }

        /*!
		 * \ref live_entities "Live blocking".
		 * \param predicate used when adding the subject
		 * \param subject_type the type of subject that will created and added
		 * \return the node that was created and added
		 * If the cardinality is restricted, might override previous values.
		 * \n Blocks only if \a predicate has no local value and an incompatible source.
         */
		LiveNode baseAddSubject(LiveNode const &predicate, CppType subject_type) const { return addSubject(predicate, subject_type); }

		//! \overload
		//! \param Predicate_ determines the predicate iri and internal subject type
			template<typename Predicate_>
		typename AutoGen::Property<Predicate_>::Type baseAddSubject() const;

		virtual LiveNode addSubject(LiveNode const &predicate, CppType subject_type) const = 0;

			template<typename Predicate_>
		LiveNode addSubject() { return addSubject(Predicate_::iri(), CppType::of<typename Predicate_::Range>()); }

        /*!
		 * \ref live_entities "Live non-blocking".
		 * \param predicate used when removing the subject.
		 * If blank or empty, the given \a subject is removed from all properties from this node.
		 * \param subject the subject that will be removed
		 * If blank or empty, all subjects with the given \a predicate are removed from this node.
		 * \n If both \a predicate and \a subject are blank or empty, all triples in the graph where this node appears as a subject are removed.
		 * \n Caution is advised with this usage, as all third party properties will be removed as well.
		 * \n \ref removeInterface method offers a more refined mechanism for removing associations.
		 * \n Blocks only if \a predicate has no local value and an incompatible source or
		 * if \a subject has no local value and an incompatible source.
         */
		void baseRemoveSubject(LiveNode const &predicate, LiveNode const &subject) const { return removeSubject(predicate, subject); }
		virtual void removeSubject(LiveNode const &predicate, LiveNode const &subject) const = 0;

			template<typename Predicate_>
		void baseRemoveSubject( typename AutoGen::Property<Predicate_>::Type const &subject) const
		{ removeSubject(Predicate_::iri(), AutoGen::Property<Predicate_>::toNode(subject)); }

        /*!
		 * \ref live_entities "Live blocking".
		 * Removes the subjects constrained by given \a predicate and \a subject with this node as the subject.
		 * \n Blocks only if \a predicate or \a subject has no local value and an incompatible source.
		 * \sa property_caching
         */
		void baseRemoveSubjects(RDFVariable const &predicate = RDFVariable(), RDFVariable const &subject = RDFVariable()) const { return removeSubjects(predicate, subject); }
		//! \overload
			template<typename Property_>
		void baseRemoveSubjects(RDFVariable const &subject = RDFVariable()) const
		{ removeSubjects(Property_::iri(), subject); }

		virtual void removeSubjects(RDFVariable const &predicate = RDFVariable(), RDFVariable const &subject = RDFVariable()) const = 0;

			template<typename Property_>
		void removeSubjects(RDFVariable const &subject = RDFVariable()) const
		{ removeSubjects(Property_::iri(), subject); }

		/*!
		 * \ref live_entities "Live non-blocking".
		 * Removes the given \a interface_name from this node.
		 * \n More specifically, runs a query which removes all triples where:
		 * \n 1. this node is the subject, and the rdfs:domain of the predicate is \a interface_name or any subclass.
		 * \n 2. this node is the object, and the rdfs:range of the predicate is \a interface_name or any subclass.
		 * \n 3. this node is the subject, predicate is rdf:type, and object is \a interface_name or any subclass.
		 */
		virtual void removeInterface(QUrl const &interface_name) const = 0;

		/*!
		 * \ref live_entities "Live non-blocking".
		 * Removes the given resource completely from the database, equivalent to
		 * removing all triples where this resource is either as subject, predicate or object.
		 */
		virtual void remove() const = 0;

        /*!
		 * Not implemented! Emitted when a given \a subject was added to the given \a predicate set of this node
         */
		Q_SIGNAL void subjectAdded(LiveNode const &predicate, LiveNode const &subject) const;
        /*!
		 * Not implemented! Emitted when a given \a subject was removed from the given \a predicate of set this node
         */
		Q_SIGNAL void subjectRemoved(LiveNode const &predicate, LiveNode const &subject) const;

/*
		virtual QSharedPointer<LiveResource> getInterface(Node const &interface_name) const = 0;
		virtual QSharedPointer<LiveResource> getInterface(QUrl const &interface_name) const = 0;

			template<typename NodeInterface_>
		inline QSharedVirtualInheritEnabledPointer<NodeInterface_, LiveResourcePtr> getInterface();

			template<typename Interface_>
		static int interfaceId();
*/
	protected:
		friend class LiveResourceBridgeMixin<>;
	public:
		virtual void attachInterface(QUrl const &interface_name, LiveResource &interface) = 0;
		virtual void detachInterface(QUrl const &interface_name, LiveResource &interface) = 0;

		virtual void startObserving(QString const &property) = 0;
		virtual void stopObserving(QString const &property) = 0;

		virtual void beginInterfaceModifications() { return beginInterfaceModifications(false); }
		virtual void endInterfaceModifications() = 0;

		virtual int implHasProperties(RDFProperty &property_data) const = 0;
		virtual LiveNodes implGetProperties(RDFProperty &property_data, RDFVariableList const &additional_columns = RDFVariableList()) const = 0;

		virtual void beginInterfaceModifications(bool discard_modifications) = 0;
/*
		static void bindPropertyToSignal(QString property_name, const char *signal)
		{
			property_to_signal[property_name] = signal;
			signal_to_property[signal] = property_name;
		}
		void connectNotify(const char *signal_name) { startObserving(signal_to_property[signal_name]); }
		void disconnectNotify(const char *signal_name) { stopObserving(signal_to_property[signal_name]); }
		void emitChangedSignal(QString const &property_name) { QMetaObject::invokeMethod(this, property_to_signal[property_name]); }
	private:
		static QHash<QString, const char *> property_to_signal;
		static QHash<QString, QString> signal_to_property;
		static int registerProperties()
		{
			bindPropertyToSignal("baseObjectAdded", SIGNAL(baseObjectAdded(LiveNode const &predicate, LiveNode const &object)));
			bindPropertyToSignal("baseObjectRemoved", SIGNAL(baseObjectRemoved(LiveNode const &predicate, LiveNode const &object)));
			bindPropertyToSignal("subjectAdded", SIGNAL(subjectAdded(LiveNode const &predicate, LiveNode const &object)));
			bindPropertyToSignal("subjectRemoved", SIGNAL(subjectRemoved(LiveNode const &predicate, LiveNode const &object)));
			return 0; // qRegisterMetaType<LiveResource>();
		}
*/
	public:
	};

	inline LiveNode::LiveNode() {}
	inline LiveNode::LiveNode(LiveNode const &cp) : Base(cp) {}

		template<typename ResourceType_, typename Policy_, typename MD_>
	inline LiveNode::LiveNode(ValueOfLiveResource<ResourceType_, Policy_, MD_> const &cp) : Base(cp) {}

	inline LiveNode::LiveNode(LiveResourcePtr resource) : Base(resource) {}

		template<typename Other_>
	inline LiveNode::LiveNode(QSharedVirtualInheritEnabledPointer<Other_, LiveResourcePtr> const &resource)
		: Base(resource) {}

		template<typename Other_>
	inline LiveNode::LiveNode(QSharedPointer<Other_> const &resource)
		: Base(resource) {}

		template<typename Other_>
	inline LiveNode::LiveNode(QWeakPointer<Other_> const &resource)
		: Base(resource) {}

	inline LiveNode::LiveNode(Node const &node) : Base(node) {}
	inline LiveNode::LiveNode(QUrl const &iri) : Base(Node(iri)) {}
	inline LiveNode::LiveNode(QString const &string) : Base(Node(string)) {}
	inline LiveNode::LiveNode(LiteralValue const &value) : Base(Node(value)) {}
	inline bool LiveNode::operator!=(LiveNode const &other) const
	{ return this->notEqual<MD>(other); }
	inline bool LiveNode::operator==(LiveNode const &other) const
	{ return !operator!=(other); }

	inline LiveNode &LiveNode::operator=(LiveNode const &other)
	{
		this->assign<LiveNode>(other);
		return *this;
	}

	inline OmniTypeLiveNode::OmniTypeLiveNode(LiveNode const &livenode)
		: ValueOfLiveResource<LiveResource, ValueOfOmniTypeLiveResource_Policy, OmniTypeLiveNode>(livenode) {}
}
Q_DECLARE_METATYPE(SopranoLive::LiveNodes)

#include "rdfservice.h"

#endif /* SOPRANOLIVE_LIVERESOURCE_H_ */
