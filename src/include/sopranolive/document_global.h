/*
 * This file is part of libqttracker project
 *
 * Copyright (C) 2009, Nokia
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public License
 * along with this library; see the file COPYING.LIB.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA 02110-1301, USA.
 */
/*
 * document_global.h
 *
 *  Created on: Jan 27, 2010
 *      Author: "Iridian Kiiskinen"
 */

#ifndef SOPRANOLIVE_DOCUMENT_GLOBAL_H_
#define SOPRANOLIVE_DOCUMENT_GLOBAL_H_

namespace SopranoLive
{
/*! \defgroup soprano Soprano
 * Internalized Soprano library
 *
 * Another intro proposal:
 * QtTracker is a full-blown RDF ORM, offering, as the major feature,
 * live connectivity and updates between local Qt/C++ resources
 * and the remote RDF service backends, while using existing Qt
 * constructs such as QAbstractItemModel extensively. QtTracker also
 * provides and uses a sophisticated RDF constraint graph builder, which
 * allows for distributed building, storage and manipulation of the
 * constraint graphs before evaluating them as SPARQL queries.
 *
 * \defgroup soprano_live SopranoLive
 * The SopranoLive library
 *
 * \page layer_raw Raw SPARQL access layer
 *
 *	Accessed through \ref SopranoLive::RDFService object, which can be
 *	obtained with \ref Tracker::service_g global method.
 *	The following methods are available:
 *	\code
	QVector<QStringList> RDFService::rawExecuteQuery(QString const &query, int type = RDFQuery::SPARQL);
	QVector<QStringList> RDFService::rawSparqlQuery(QString const &query);
	QVector<QStringList> RDFService::rawSparqlUpdateQuery(QString const &query);
	void RDFService::rawInsertTriple(QString const &subject, QString const &predicate, QString const &object);
	void RDFService::rawDeleteTriple(QString const &subject, QString const &predicate, QString const &object);
	void RDFService::rawLoad(QUrl const &uri);
 * 	\endcode
 *
 *  \page layer_autogenerated Autogenerated convenience layer
 *
 *	Convenience classes are automatically generated from ontology description
 *	rdf-xml files. They're designed to be intuitive and are sufficient for
 *	manipulating objects and their properties.
 *
 *	They are completely built on top of the bound base service layer services.
 *
 *	They offer a Qt signals/slots interface to observe the properties of an
 *	object (API support done, backend support missing)
 *
 *  \page layer_domain Domain specific helper layer
 *
 *	Optional layer for customized helper methods and objects, if required.
 *
 *  \page live_entities Live and non-live entities and operations
 *
 * \section live_entities_entities Live and non-live entities
 * Many SopranoLive entities can be specified to be in a \a live or \a non-live state.
 * \n An entity in a live state, called a \a live \a entity, acts as a proxy to some
 * remote RDF entity and offers a means of accessing a local representation of it.
 * \n An entity in a non-live state, called a \a non-live \a entity, has only a local
 * value without any remote identity.
 *
 * Classes described as "live or non-live entity" can be in either state, which can be checked
 * with the isLive method.
 * \n (as of 0.3.0 these entities are \ref LiveNode and the other \ref Live types,
 * and \ref LiveNodes and the other \ref LiveBag types)
 *
 * Classes described as "live entity" are always in a live state and their isLive method always
 * returns true.
 * \n (as of 0.3.0 these entities are \ref LiveResource and its derivatives, and LiveNodeModel)
 *
 * \section live_entities_operations Live and non-live operations
 * Live and non-live entities of the same type offer a shared set of \a non-live \a operations.
 * \n In addition to this, there are \a live \a operations that make sense only when an entity is
 * live. Using these operations with non-live entities leads to undefined behaviour (typically
 * warnings in debug, crashes in release).
 *
 * In the case of a live entity, some of the operations can be \a blocking \a operations.
 * A live entity doesn't necessarily keep its local value up to date internally, because this
 * might incur considerable overhead in the application. Instead, live entities might postpone
 * the evaluation of an actual local value to only when they are really needed.
 * For example, with LiveNode::toString(), there might be considerable delay while a request for
 * that value takes time to complete.
 * Consider:
 * \code
 * LiveNode node = other_node.getObject(some_uri); // This call will not block, as the actual local value representation isn't being accessed.
 * LiveNode nodes_parent = node.getObject(parent_property_uri); // Even this call will not block, as the backend has the necessary information to know how nodes_parent is accessed.
 * qDebug() << "Value: " << node.toString(); // This call will block while the service is queried for the actual value.
 * \endcode
 *
 * However, because all live entities have their backend implemented in the service side, the
 * service can perform optimizations and pre-caching operations to improve the efficiency.
 * For example a very typical scheme is:
 * \code
 * LiveNode node = other_node.getObject(some_uri); // pre-caching operation is initiated on the service, in form of an asynchronous pre-emptive query, which does not block.
 * timeIntensiveOperation(); // do a lot of work, during which the pre-caching operation completes
 * qDebug() << "Value: " << node.toString(); // practically instantaneous
 * \endcode
 *
 * For a non-live entity, for which all data is by definition local, all valid operations are
 * guaranteed not to block.
 *
 * To sum it up:
 * \n 1. "Non-live blocking operations" are available to both live and non-live entities, but might block live entities. Example: the \ref LiveNode::toString method.
 * \n 2. "Non-live non-blocking operations" are available to both live and non-live entities, and which never block. Example: \ref LiveNode::isLive method.
 * \n 3. "Live blocking operations" are available only to live entities, and which might block. Example: none yet.
 * \n 4. "Live non-blocking operations" are available only to live entities, but which never block. Example: \ref LiveResource::getObject method.
 *
 * (Tentative, in consideration:
 * A transaction-style mechanism will be offered where a signal is emitted once all values are
 * pre-cached, and after which all current live entity blocking operations are guaranteed to
 * be non-blocking, unless specified differently:
 * \n 5. "Non-caching operations" might block even after the pre-caching completed signal is
 * emitted. If "non-caching" is omitted, the operation is considered caching by default.
 * End tentative)
 *
 * In many cases, as long as the local value of the live entity isn't being accessed, one can
 * go relatively far in accessing subproperties of different values, before an actual blocking
 * operation happens.
 *
 * \page user_manual User manual
 *
 *
 *	\n \n \n
 *	\section user_manual_introduction 1. Introduction
 *
 *	  QtTracker is a C++/Qt object - RDF mapper client library.
 *	It contains the generic SopranoLive library and the Tracker backend module, and includes
 *	some parts of the Soprano library. This document describes primarily the generic
 *	SopranoLive part. When Tracker backend module specific functionality is described, it is
 *	always explicitly mentioned.
 *
 *	\n \n
 *	\subsection user_manual_intro_what_is_rdf 1.1. What is RDF?
 *
 *	  RDF, Resource Description Framework, is a metadata model specification by W3C. It is
 *	elegant, but all the details of it would fill many books. A short primer is given below,
 *	which suffices to start using the higher level parts of SopranoLive. Eventually, and
 *	when the lower level mechanisms are used, a more intimate knowledge of RDF is required.
 *	Covering that is outside the scope of this document. A full primer on RDF can be found
 *	at http://www.w3.org/TR/rdf-primer/
 *
 *	\n \n
 *	\subsection user_manual_intro_rdf_primer 1.2. Short RDF Primer
 *
 *	  The core building block of RDF is data that is represented as unique
 *	subject-predicate-object \a triples. Each part of the triple is represented by an URI,
 *	or in case of the object part, a literal value such as string or a numeric value.
 *  These triples describe relationships between data. Three example triples, separated by ".":
 *
 *  \code
 *	<http://example.org/contact#166122> a nco:Contact .
 *	<http://example.org/contact#166122> nco:fullname "Jack Hammer" .
 *	<http://example.org/contact#166122> nco:affiliation <http://example.org/contact#166123>
 *	\endcode
 *	  Here the subject in all triples is the url "http://example.org/contact#166122", and it
 *	identifies the resource. The predicates "a", "nco:fullname", "nco:affiliation" identify
 *	the relationships. The subjects, url "nco:Contact", literal "Jack Hammer" and url
 *	"http://example.org/contact#166123" are the payload data. The first triple uses the
 *	special predicate name "a" (short for rdf:type) to indicate that the example resource
 *	has a type nco:Contact. The second triple states that the resource has a nco:fullname
 *	property of "Jack Hammer". The third triple states that the resource has an
 *	nco:affiliation of another resource "http://example.org/contact#166123". This other
 *	resource probably has properties of its own, such as its own nco:fullname. Subjects and
 *	objects can also be 'blank nodes', which are not covered here.
 *
 *	\n
 *	\subsection user_manual_intro_rdf_primer 1.2.1. Resource URI's
 *
 *	  Generally in RDF, URIs for new resources can be of any valid uri form and are often
 *	generated by the user or some library. However, domain specific ontology solutions might
 *	choose to restrict their URIs to some common schema.
 *
 *	\n
 *	\subsection user_manual_intro_rdf_primer 1.2.2. RDF Storages and sources
 *
 *	  A single RDF triple is unique in a \a graph. A graph is a collection of triples and an
 *	identifying URI. RDF stores and sources are collections of these graphs. Each store usually
 *	has a single unnamed graph. All other contained graphs have URI identifiers. You will
 *	encounter term 'quad' eventually in context of rdf. Quad means a triple extended with
 *	the graph uri it appears in; subject-predicate-object-graph quad.
 *	\n \n   This multilevel structure allows for the nature of RDF to be very open-ended, where
 *	different RDF data sources describe different aspects of the same resource. To reflect this,
 *	there are many different formats to actually represent sets of triples and quads. For
 *	SopranoLive, the relevant formats are turtle (storage format) and SPARQL (query format).
 *
 *	\n \n
 *	\subsection user_manual_intro_rdf_primer 1.2.1. RDF Ontologies
 *
 *	  The structure for RDF data is described by \a ontologies, primarily around concepts of
 *	classes and properties. Fundamentally all data in RDF is just triples in graphs, there is
 *	no hard structure. The class and property system is directly built on top of this, but
 *	is also self-referential.
 *	\n Resources can have types. Plain data triple:
 *  \code
<http://example.org/contact#166122> a nco:Contact .
 *	\endcode
 *	Properties describe resources such as nco:fullname, to have range and domain.
 *	\n Set of ontology triples describing nco:fullname to have nco:Contact as domain and
 *	xsd:string as range:
 *  \code
nco:fullname a rdf:Property .
nco:fullname rdfs:domain nco:Contact .
nco:fullname rdfs:range xsd:string .
 *	\endcode
 *
 *	When a triple having such a resource as predicate is added, this description is meaningful.
 *  \n A plain data triple:
 *  \code
<http://example.org/contact#166122> nco:fullname "Jack Hammer" .
 *	\endcode
 *
 *  From this, we can now \a infer by using ontology description of nco:fullname that the resource
 *  <http://example.org/contact#166122> has the type nco:Contact.
 *
 *	  An ontology is identified by a URI, and often has a shorthand form. We already encountered
 *	\a nco, which stands for nepomuk contact ontology. The "nco:Contact" is a short-hand notation,
 *	internally the nco is expanded to form
 *	"http://www.semanticdesktop.org/ontologies/2007/03/22/nco#Contact". Ontologies also contain
 *	other things, such as values, default values, 'global' resources, and so on. As we saw
 *	previously, an ontology is itself defined in terms RDF triples. The fundamental ontologies
 *	\a rdf, \a rdfs and some others, given to us by W3C, describe the classes and properties used
 *	for describing ontologies. Using these, anyone can write their own new ontologies.
 *	Whether anyone will use them, is a different matter though. Because of this, there are
 *	initiatives such as Nepomuk which try to offer centralized versions of ontologies that
 *	cover their own general problem domains.
 *
 *	\subsection user_manual_intro_bridge 1.2.4. SPARQL
 *
 *	  SPARQL is a query language for RDF data. It's specification can be found at
 *	http://www.w3.org/TR/rdf-sparql-query/ . It is built around the concepts of variables,
 *	triple patterns and graph patterns. A triple pattern is a single triple which can contain
 *	variables and fixed values. Graph pattern is a collection of triple patterns and child
 *	graph patterns.
 *	\n SPARQL for selecting for a title of a known resource:
 *  \code
SELECT ?title
WHERE
{
  <http://example.org/book/book1> <http://purl.org/dc/elements/1.1/title> ?title .
}
 *	\endcode
 *
 *	\n SPARQL for selecting first 50 direct and affiliated email addresses from all contacts:
SELECT ?_contact ?_email ?_email_text
WHERE
{
    ?_contact a nco:Contact .
    {
        ?_contact nco:hasEmailAddress ?_email .
    }
    UNION
    {
        ?_contact nco:hasAffiliation ?_aff .
    	?_aff nco:hasEmailAddress ?_email .
    }
    ?_email nco:emailAddress ?_email_text
}
  ORDER BY ?_contact
  LIMIT 50
 *
 *	\n \n
 *	\subsection user_manual_intro_bridge 1.4. Bridging between RDF and C++/Qt
 *
 *	  SopranoLive maps the RDF data model and ontologies into C++/Qt objects. The RDF data
 *	sources are represented by a RDF service objects (\ref RDFService), supplied by specific
 *	backends.
 *
 *	  These objects offer services with different levels of abstraction, ranging
 *	from low level direct queries returning raw RDF data, to high level live proxy objects
 *	that reflect the resource state changes in the backend data source. The choice of
 *	access level depends on the desired amount of control. The high level access mode
 *	offers powerful tools covering most scenarios, which ensure performance without
 *	compromising usability and code readability. However, there will always be cases,
 *	where the high level tools cannot express the solution, or where competitive performance
 *	can be only achieved using the lower level mechanisms. The decision on what level of
 *	abstraction is used is not permanent: all levels are designed to work together to
 *	reasonable extent.
 *
 *	\n \n
 *	\subsection user_manual_intro_tracker 1.5. Tracker backend
 *
 *	  The Tracker backend is used to access the local, current user Tracker metadata database through DBus. Tracker is a fixed ontology, single (unnamed) graph, RDF triple store database. It is currently the main reason for the existence of SopranoLive.
 *
 *
 *
 *	\n \n \n
 *	\section user_manual_overview 2. SopranoLive Overview
 *
 *	\n \n
 *	\subsection user_manual_over_levels 2.1. Levels of abstraction - The People of the Three Ages
 *
 *	    SopranoLive is no simple library, but doing full service data access never is. This is
 *	  why three different approaches to using SopranoLive can be identified. They're called
 *	  the hunter-gatherer, the industrialist and the transcendental.
 *
 *	2.1.1. The Hunter-Gatherer
 *
 *	    Hunter-gatherers use SopranoLive as thin layer to access the backend. Queries are written
 *	  in SPARQL directly and receive results as sets of plain data string lists or Qt models
 *	  (\ref LiveNodes referencing \ref LiveNodeModel, a QAbstractItemModel derived class).
 *	  Very direct and efficient, hunter-gatherer has the finest possible control. Just like their
 *	  historical counterparts however, they require intrinsic knowledge of the RDF environment
 *	  and their SPARQL tools, and have to replicate a lot of manual work that might be offered by
 *	  the higher levels, such as string escaping issues, query updating and streaming results.
 *	  They require least knowledge of the library, especially if they get the results as plain
 *	  data form and not in Qt models.
 *
 *	2.1.2. The Industrialist
 *
 *	    An industrialist has a considerable set of tools he can use, and his code is shorter, more
 *	  modular and readable. They are traditionalists, and use SopranoLive like a conventional
 *	  database access library, using query builder elements (\ref RDFVariable, \ref RDFPattern,
 *	  \ref RDFSelect, \ref RDFUpdate) with generated ontology classes to query and manipulate data.
 *	  Using query builder elements allows them to use live query strategy to get updates to their
 *	  models, and streaming query strategy to get first results faster and to lighten the load on
 *	  the database. Their data is correctly typed and they get compile time checking on their query
 *	  building.
 *
 *	  An Industrialist still has to know the RDF and the ontologies. They're a step further from
 *	  keeping track of what queries are being made to the backend, especially if they're using
 *	  live or streaming query strategies. They require considerable knowledge of the library.
 *
 *	2.1.3. The Transcendental
 *
 *	    A transcendental uses the SopranoLive to the fullest as an ORM and has the database
 *	  resources as first-class C++ objects (\ref LiveNode, \ref Live) that can be the primary
 *	  client-side data storage and be passed around in true OO fashion. They use query builder
 *	  like the industrialist, but extend it with \a derived \a property information to enable
 *	  sensible data precaching. By doing this and \a only \a by \a doing \a this they can use live
 *	  resource based access \a efficiently and to take the final step of object-RDF-mapping
 *	  transcendence. How and why the derived properties must be used and how the caching system
 *	  works is covered in its own section. Failure to properly describe derived property
 *	  relationships will result in broken data precaching. This easily leads to thousands of
 *	  trivial property access queries which will wreack havoc on performance even on local RDF
 *	  databases.
 *
 *	  When done correctly, a transcendental has his database as first-class C++ objects, with
 *	  generated property functions with generated reference documentation. Transcendental code
 *	  is most compact and in principle intuitive to read and understand. The learning curve is
 *	  easy at first. But doing the derived property data precaching correctly is a necessary bump.
 *
 *	2.1.4. Smooth transition between modes.
 *
 *	    The boundaries between these three categories are not strict. Interaction between
 *	  different levels of code is smooth, as the later levels are built on top of the previous
 *	  ones. A lot of the time, a Transcendental is using Industrial services, and all users share
 *	  some objects (RDFService). The distinction is only a tool to give a rough idea on how to
 *	  approach the complex library. Code examples will be marked according to what type most
 *	  typical users of the particular code snippet are expected to be.
 *
 *	\n \n
 *	\subsection user_manual_over_core 2.2. Core concepts - Dance of the Two Worlds
 *
 *	  SopranoLive's core tenet is to define the interplay between entities of the bound and unbound worlds. This is a fancy way of saying that first we build a query. It is not bound to any data or any databases, and is thus unbound. We then execute the query against a source graph in some RDF service, and get results back. The result data knows and remains connected to its source. It is bound. Entities of the unbound world ("unbounds" from here on) cover URIs, variables, patterns, regexps, filters, and generally speaking any data that is used for searching and matching.
 *	Entities of the bound world ("bound entities") are single values or sets of resources connected to graphs in the RDF services. These resources are URI identified objects, or literal values like strings or numbers. As mentioned before, these unbounds are used to match data from the graphs, and through "binding" operations, typically by running a query, and then yield sets of bound entities.
 *
 *	\n \n
 *	2.2.1. URI and LiveNode
 *
 *	  The simplest unbound is a URI, represented by a QUrl. When bound to a graph, a matching bound resource represented by LiveNode, is obtained. This LiveNode now represents the resource identified by the URI in the graph. It can then be used as a basis of manipulating or accessing its properties, or as a stepping stone for further browsing of other bound resources.
 *
 *	\code
 *	  // Main user: Industrialist
 *	  RDFGraphPtr graph = ::tracker() // obtain the tracker backend default graph
 *	  QUrl resource_id("http://example.com/resource#12"); // must be a valid QUrl
 *	  LiveNode resource = graph->liveNode(resource_id); // access
 *	  qDebug() << resource->getObject<nco::fullname>().toString(); // print the nco:fullname property
 *	\endcode
 *
 *	  LiveNode is the bare basic form, but there are others with slightly different semantics, or added convenience functionality. Most notably, Live<nco::Contact> is a LiveNode with autogenerated functions for direct property access.
 *
 *	\n \n
 *	2.2.2. Pairing of an RDFVariable and LiveNode through binding
 *
 *	  An RDFVariable is the generic unbound entity, a building block of graph pattern matching. Like dancers in a row, RDFVariable unbounds can be connected to each other. When this group of RDFVariable unbounds is "bound" to a graph, similarily connected sets of LiveNode bound entities are returned. In each returned set every LiveNode must match the requirements of its counterpart RDFVariable, just like the row of dancers get their matching partners.
 *
 *	\code
 *	  // Main user: Industrialist
 *	  RDFVariable entity_var = QUrl("http://example.com/resource#12"); // entity_var constrained to the given url
 *	  RDFVariable affiliates_var = entity_var.property<nco::affiliation>(); // get a variable representing nco:affiliation set of entity_var
 *	  RDFVariable affiliate_names_var = affiliates_var.property<nco::fullname>(); // get a variable representing nco:fullname of the affiliates_var
 *	  affiliate_names_var.contains("Rhett"); // constrain affiliate_names_var to contain the string "Rhett"
 *	\endcode
 *
 *	\n \n
 *	2.2.3. Querying the initial stance with RDFSelect
 *
 *	  Making a selection query is perhaps the most idiomatic method of binding. Once we have our group of connected RDFVariable unbounds, we create an RDFSelect object and choose the RDFVariable unbounds we want to map into columns in the result set. We then "model" this query on a graph and receive the results in a table form, represented by a LiveNodes object. Each row in the result set represents a unique combination of bound resources which fully match the group of unbounds. Each column represents the particular unbound we chose to see from the full group, and contains the matching bound resources.
 *
 *	\code
 *	  // Main user: Industrialist
 *	  // .. continued from the previous code examples
 *	  RDFSelect sel;
 *	  sel.addColumn("Affiliation", affiliate_names);  // We're interested only in the affiliate_names
 *	  LiveNodes res = graph->modelQuery(sel); // model it.
 *	  for(int i = 0; i < res->rowCount(); ++i)
 *		qDebug() << "Affiliation" << res->liveNode(i).toString();
 *	  // We get all the fullnames of affiliations of the resource "http://example.com/resource#12"
 *	\endcode
 *
 *	\n \n
 *	2.2.4. Interplay of RDFVariable and LiveNodes
 *
 *	  Every bound entity knows its graph and either a single or set of "source" RDFVariable unbounds. When the graph and these source unbounds are once again bound together, the same original bound entity is obtained. These unbounds can be combined with other unbounds thus allowing for further queries, and the dance begins anew. Much of this work is streamlined and automated. For example, the dance in the previous examples could be represented as:
 *
 *	\code
 *	  // Main user: Transcendental
 *	  // get the contact, assign it to a LiveNode of type nco:Contact
 *	  Live<nco::Contact> contact = ::tracker()->liveNode(QUrl("http://example.com/resource#12"));
 *	  RDFVariable aff_constraints;
 *	  aff_constraints.property<nco::fullname>(LiveNodeModel::Caching).contains("Rhett");
 *	  LiveNodes res = contact->getAffiliations(aff_constraints);
 *	  for(int i = 0; i < res->rowCount(); ++i)
 *		qDebug() << "Affiliation" << res->liveResource<nco::Contact>(i)->getFullname();
 *	\endcode
 *
 *	\n \n
 *	2.2.5. Change of Positions
 *
 *	  Reading content is only half of the equation. For the Transcendental, the 'Live' entities offer an intuitive, getter/setter/adder/remover-style of approach for writing single or multiple valued properties for the resources. Industrialist uses RDFUpdate which offers a query-based interface for both fine-tuned individual operations and for bulk change operations.
 *
 *	\n \n
 *	2.2.6. Object Ownership and Memory Management
 *
 *	  Most of the library objects are accessed by-value, and their internal, possibly shared, data is automatically managed. In cases where the internal shared data is directly accessed, memory management is performed using shared pointers (\ref QSharedPointer). Most notably, this is the case when \ref LiveNodeModel (which inherits a QAbstractItemModel) is accessed and managed by a LiveNodes object.
 *
 *
 *
 *	\section user_manual_tutorials 3. Tutorials
 *	\subsection user_manual_tutorials_preparing Preparing the development stage
 *	  QMake
 *	\subsection user_manual_tutorials_menuets Three Menuets - Three Pairs
 *	\subsection user_manual_tutorials_waltz Selecting e-mails by sender name - Two waltz interpretations
 *	Select all \a e-mails coming from a sender/senders with a given \a name using the nmo ontology, and obtain the individual \a e-mails and their contents in a result table with LiveNodes.
 *	More specifically, select for all nmo::Email objects (as \a e-mails) with \a nmo::from property, with \a nco::nameGiven property of \a name. Then map the \a e-mails in the first column and the nmo::plainTextMessageContent of the \a e-mails in second column.
 *	First the Industrialist take:
 *	\code
LiveNodes getEmailsFromName(QString name)
{
	RDFVariable emails = RDFVariable::fromType<nmo::Email>();
		// \a emails is initialized from an RDFVariable which is constrained to all nodes of type nmo:Email.
		// Make use of the ontology convenience class nmo::Email.
	RDFVariable sender;
		// Initially, \a sender represents all resources. We know that typically the sender is an nco::Contact, but it is not necessary to enforce that constraint here.
	sender = emails.property<nmo::from>());
		// Obtain the nmo::from property of \a e-mails, and constrain \a sender to it. We have now specified that any resources which being bound as \a e-mails must have been sent by some entities that get bound as \a sender.
	sender.property<nco::nameGiven>() = LiteralValue(name);
		// Further constrain the nco:nameGiven property of sender to the string \a name.

		// What we have done so far is to add constraints to one RDFVariable connect it in a triple relationship. In the relationship, \a e-mails is the subject, nco::nameGiven is the predicate and the literal \name is the object.
		// Now \a emails represents all objects of type nmo::Email that come from senders who have nco::nameGiven set to \a name.

		// Next we build the query and get the \a subject of each of those \a e-mails in the result as well.

	RDFSelect select;
		// Create the selection object
	select.addColumn("EmailId", emails);
		// Add a new column with header name "EmailId", and set it to represent the \a emails variable. What will appear in this column are the uri identifiers of all the nmo::Email objects getting bound in the role of \a e-mails.

	RDFVariable content = emails.property<nmo::plainTextMessageContent>();
		// Obtain the nmo::messageSubject of \a emails. This has the additional effect of creating another triple relationship constraint, where \a emails is once again the subject, nmo::messageSubject is the predicate, and the returned \a content is the subject.
	select.addColumn("EmailContent", content);
		// Add a new column "EmailSubject" after the previous column, represented by \a content.

	return ::tracker()->modelQuery(select);
		// Bind the query with ::tracker() source graph, which yields us the results as a table in a LiveNodes object. This table contains one row for each unique combination of triple to variable mappings in the graph which match the constraints we just specified. The first column contains the \a email's uris, and the second column contains the contents of these e-mails.
		// LiveNodes is a smart, shared pointer to a LiveNodeModel, which in turn extends QAbstractItemModel containing the actual result table data. As the model is shared by LiveNodes, we can pass it around cheaply. The model gets destroyed only when last LiveNodes sharing it is destroyed.
	;
}
 *	\endcode
 *
 *	The same functionality, as done by a Transcendental:
 *	\code
// Main user: Transcendental
LiveNodes getEmailsFromName(QString name)
{
	RDFVariable emails = RDFVariable(LiteralValue(name)).subject<nco::nameGiven>().subject<nmo::from>(RDFVariable("EmailID"));
		// Start building the constraint graph from \a name. Use RDFVariable::subject to build the triple constraints in the reverse order to how RDFVariable::property works.
		// Also, specify the column header name as part of the RDFVariable itself.

	emails.addCachedProperty<nmo::messageSubject>(RDFVariable("EmailContent"));
		// Instead of explicitly adding the content as a column directly, give a hint to the backend to have the nmo::messageSubject cached for all \a e-mails.
		// The backend implementation then does the best it can to efficiently cache the messageSubject for the user. Incidentally, this typically translates directly into adding a new column to the query, just like in the explicit Industrialist version before. Similarily, the cached properties' lifetime is also strictly bound to the resulting model.

	return ::tracker()->modelVariable(emails, RDFStrategy::DefaultStrategy | RDFStrategy::ExposeCachedProperties);
		// Typically, the cached properties would be accessed through accessor functions in live nodes, to allow for a transparent caching strategy change. We may for one reason or another, specify that we require the cached properties to be directly visible in the resulting query. The results are now identical to the previous example.
}
 *	\endcode
 *	\subsection user_manual_tutorials_ballet Ballet
 *	\subsection user_manual_tutorials_war_dance Raw access - The Hunter War Dance
 *
 *
 *
 *	\n \n \n
 *	\section user_manual_interplay 4. Theoretical principles
 *
 *	  The core tenet in SopranoLive is to define the interplay between entities of the bound and unbound worlds. Entities of the unbound world represent URIs, variables, patterns, regexps, filters, and generally speaking any data that is used for searching and matching. Unbound entities can be combined, merged and modified, giving us our first production:
 *
 *	\n \n
 *	\subsection user_manual_inter_merging 4.1. Merging: Unbound + Unbound -> Unbound
 *
 *	Entities of the bound world are resources belonging to graphs in the RDF services. Sometimes the interaction is simple. An unbound query is built, executed on a graph and bound results are received, used and discarded. Thus we have our second production:
 *
 *	\n \n
 *	\subsection user_manual_inter_binding 4.2. Binding: Unbound + Graph -> Bound
 *
 *	A bound resource always knows its source graph, and some set of unbound entities that can be used to find it from the graph again. We get our third production:
 *
 *	\n \n
 *	\subsection user_manual_inter_unbinding 4.3. Unbinding: Bound -> Unbound + Graph
 *
 *	In the majority of cases, this "unbound" is typically just a single or set of URIs, but with backends supporting blank nodes, and in some optimization scenarios, it might be something more complex.
 *	Often we use longer interplay sequences, for example, when browsing from an initial bound resource through some unbound search criteria to other bound resource(s) and onwards. We can use the production 1 on production 2, and 3 on the result, to derive our fourth production:
 *
 *	\subsection user_manual_inter_browsing 4.4. Browsing: Bound + Unbound -> Unbound + Graph + Unbound -> Unbound + Graph -> Bound
 *
 *
 *
 *
 *	\section user_manual_unbound 5. Query Building
 *
 *	  Query building is unarguably the most central part of working with SopranoLive.
 *	Be it raw SPARQL, industrialist modelQuery or transcendental derived property pre-caching,
 *	queries are going to built. In the following section we'll cover how to use
 *	\ref RDFVariable, \ref RDFPattern, \ref RDFSelect and \ref RDFUpdate to build queries
 *	and get and modify data with them. While SPARQL knowledge is not required as such,
 *	understanding SPARQL will in practice be very helpful. To help achieve this goal, every
 *	example is paired with corresponding SPARQL.
 *
 *	\subsection user_manual_unbound_rdfvariable RDFVariable and RDFSelect
 *
 *	\code
void EmailViewer::refreshEmails()
{
    // model all e-mails
	RDFVariable emails = RDFVariable::fromType<nmo::Email>("Email IRI");
	// ..
	RDFSelect email_selection;
	email_selection.addColumn(emails);
	// execute the query
	this->query_model = ::tracker()->modelQuery(email_selection);
	this->query_model->setAsModelInto(this->query_view); // set to QListView
	// Corresponding SPARQL for email_selection
	// SELECT ?Email_IRI
	// {
	// 	# $emails
	// 	?Email_IRI a nmo:Email
	// }
 *	\endcode
 *
 *   RDFVariable is the core query building block. An RDFVariable is an RDF resource variable
 * used in queries. When a query is executed, the set of all connected RDFVariable objects and
 * their constraints, together called a \a query \a graph, is used to enumerate a set of different
 * matching solutions from the data. A solution candidate is formed by choosing a single resource
 * value from the data (or null) for each variable. A set of all solution candidates is thus the
 * set of all combinations of values for all variables in the query graph. And finally, a matching
 * solution (just a \a solution from now on) is a solution candidate for which all the constraints
 * in the query graph are true.
 *
 * In an RDFSelect query, some of the RDFVariable objects are mapped to columns. Once executed,
 * each solution is then used for form a row to a \a result \a set. A row is formed from a solution
 * by picking the the value that corresponds to the column variable for all columns.
 * \n In SPARQL, an RDFVariable maps to a variable ("?variable") and RDFSelect maps to a selection
 * query ("SELECT").
 * \n
 * \n  However, as opposed to SPARQL, SopranoLive query building is distributed. A single
 * RDFVariable instance is actually just a \a handle to a variable in the underlying query
 * graph. Many RDFVariable instances can thus actually end up referring to the same variable in
 * the final query. Such RDFVariable objects are said to be aliases of each other.
 * Also, as long as any RDFVariable handle is kept alive, the whole connected query graph is kept
 * alive. This allows for creation of complex constraints and returning them in with a single
 * RDFVariable. When it is eventually connected with another RDFVariable objects, their
 * underlying query graphs are thus also connected together as a result.
 * \n
 * Let's create a function which returns a variable that corresponds to all contacts which
 * contain a user supplied name as part of their fullname, using \ref RDFVariable::property and
 * \ref RDFVariable::contains :
 * \code
RDFVariable contactFromName(QString contained_name_string)
{
	RDFVariable ret_contact("contact");
	ret_contact
		.property<nco::fullname>(RDFVariable("fullname"))
		.contains(contained_name_string);
	return ret_contact;
}
 * \endcode
 * Corresponding SPARQL
 * \code
{
	# $ret_contact
	?contact nco:fullname ?fullname .
	FILTER(REGEX(?fullname, "<contained_email_string>"))
}
 * \endcode
 *
 * Let's add code that builds a select query for getting all contacts and their email addresses,
 * using \ref RDFSelect, \ref RDFSelect::newColumn and \ref RDFSelect::addColumn:
 *
 * \code
RDFSelect sel;
RDFVariable contact = sel.newColumn<nco::Contact>("contact");
sel.addColumn("email", contact
		.property<nmo:hasEmailAddress>(RDFVariable("email_uri"))
		.property<nmo:emailAddress>()
		);
 * \endcode
 * Corresponding SPARQL:
 * \code
SELECT ?contact ?email
{
	# $contact
	?contact a nco:Contact .
	?contact nmo:hasEmailAddress ?email_uri .
	?email_uri nmo:emailAddress ?email
}
 * \endcode
 *
 * And finally, let's merge these two pieces together using \ref RDFVariable::merge and build
 * the SPARQL query using \ref RDFQuery::getQuery:
 *
 * \code
contact.merge(peopleFromEmailAddress(string_from_editbox));
qDebug() << sel.getQuery();
 * \endcode
 * Corresponding SPARQL:
 * \code
SELECT ?contact ?email
{
	# $contact $ret_contact
	?contact a nco:Contact .
	?contact nmo:hasEmailAddress ?email_uri .
	?email_uri nmo:emailAddress ?email .
	?contact nco:fullname ?name .
	FILTER(REGEX(?name, "<contained_name_string>"))
}
 * \endcode
 *
 *   An RDFSelect is a 'view' into a one or more query graphs. It does not connect its column
 * variables together nor does it make any other changes unless specified. You can have many
 * RDFSelect objects viewing the same query graph without them being aware of each other.
 * If the RDFVariable graph is modified after generating the query, the next time the RDFSelect
 * is executed, a different query will be generated.
 *
 *	\subsection user_manual_unbound_rdfpattern RDFPattern
 *
 *   An RDFPattern is a handle to a collection of constraints. Each RDFVariable is associated
 * with one. When new constraints are specified through the RDFVariable, they are actually
 * placed in the associated RDFPattern. The RDFPattern objects can have non-cyclic child
 * RDFPattern objects, thus making the query structure of RDFPattern objects a tree. By default,
 * all the constraints (even the recursive child patterns) in a single RDFPattern must match the
 * solution candidate for the RDFPattern itself to be considered to match. This would make the
 * tree structure of default connected RDFPatterns quite redundant, as a single RDFPattern
 * containing all the constraints would be semantically equal. But an RDFPattern can have
 * one of many specifiers that changes the way it interacts with its parent and sibling
 * RDFPattern objects, thus making the tree structure semantically meaningful.
 * \n
 * \n  In SPARQL, an RDFPattern represents a single graph pattern, or a region between two
 * matched braces "{ ... }". In the SPARQL examples all graph patterns have a comment listing
 * all RDFVariable objects associated with it, like "# $contact $ret_contact" in the above
 * example. In SPARQL, the tree structure is expressed through recursive
 * "{ ... { ... } { ... { ... } { ... } } }" layout.
 *
 *	\subsection user_manual_unbound_rdfpattern_specifiers RDFPattern specifiers
 *
 *	RDFPattern specifiers change the way the RDFPattern interact with the rest of the query.
 * \ref RDFPattern::graph specifies that the constaints are matched only against triples inside
 * a specific \a named \a graph. \ref RDFPattern::exists and \ref RDFPattern::notExists filter
 * existing solution candidates based on whether the pattern would match any (for \a exists) or
 * no (for \a not \a exists) solution candidates if it counted towards new solution candidates,
 * but doesn't actually contribute. Conversely, \ref RDFPattern::optional does count towards
 * new solution candidates, but doesn't filter out other solution candidates even if it itself
 * doesn't match. RDFPattern::union_ combines two or more RDFPattern objects together, and
 * matches if any of the combined RDFPatterns matches. These specifiers are covered in greater
 * detail later on.
 * \n
 * \n  In SPARQL, the specifiers are keywords that are placed in front of or in between
 * graph patterns like
 * "{ ... NOT EXISTS GRAPH <bar> { ... } OPTIONAL GRAPH <foo> { ... { ... } UNION { ... } } }".
 *
 *	\subsection user_manual_unbound_rdfvariable_constraints RDFVariable constraints
 *
 *   Primary way to constrain a RDFVariable is to connect it to other RDFVariable
 * objects in a property relationship. For example, consider an RDFVariable represent an e-mail
 * and another RDFVariable representing a contact. They can be connected together by specifying
 * that the contact is the sender of the e-mail. The contact RDFVariable might also be
 * constrained by specifying that its full name should begin with "A". The following code
 * demonstrates connecting and constraining RDFVariable objects.
 *
 * \code
RDFVariable contact = RDFVariable::fromType<nco::Contact>("contact");
RDFVariable email = RDFVariable::fromType<nmo::Email>("email");

// Connect the variables
// In this simple example, all the six following are equivalent:
email.property<nmo::from>(contact);
contact = email.property<nmo::from>();

email.object<nmo::from>(contact);
contact = email.object<nmo::from>();

contact.subject<nmo::from>(email);
email = contact.subject<nmo::from>();

// Restrict the RDFVariable representing the contact
contact.property<nmo::fullname>().hasPrefix("A");
 * \endcode
 * Corresponding SPARQL
 * \code
{
	# $contact $email
	?contact a nco:Contact .
	?email a nmo:Email .
	?email nmo:from ?contact .
	?contact nmo:fullname ?_1 .
	FILTER(REGEX("^A"))
}
 * \endcode
 *
 * In addition to being a handle objects, any RDFVariable (and RDFPattern) object referring
 * to a resource inside the query graph keeps the whole query graph and its resources alive.
 * In other words, destroying an RDFVariable instance doesn't remove any constraints from
 * the query graph unless it was the last handle. Once the last handle is released, the whole
 * query graph and its associated resources are destroyed.
 *
 * A variable is \a unknown when no constraints have been added to it. RDFVariable::subject(),
 * RDFVariable::property() and RDFVariable::object() add constraints to the variable by
 * connecting it to other RDFVariable objects.
 *
 * Both
 *
 * \code
contact.subject<nmo::from>(email);
 * \endcode
 *
 * and
 * \code
email.object<nmo::from>(contact);
 * \endcode
 *
 * declare that the contact (represented by RDFVariable "contact") is the sender
 * of the e-mail (represented by RDFVariable "email"). The first one adds this
 * restriction to the variable "contact" and the second one adds the
 * restriction to the variable "email". In simple use cases, it does not
 * matter to which variable the constraint is added. But in more complex use
 * cases, e.g., when RDFVariable objects are in a union relationship, the
 * difference is important. See \ref user_manual_unbound_rdfvariable_unions.
 *
 * \subsection user_manual_unbound_rdfvariable_unions Unions
 *
 * With the union construct, you can combine different RDFVariables into a
 * single column of the result set.
 *
 * A simple way to union is to create a new RDFVariable and call
 * RDFVariable::unionMerge() with a list of already-existing RDFVariable
 * objects which have not yet been connected to main query; these will be
 * joined in a union relationship. The RDFVariable representing the union
 * can be added as a column to a RDFSelect.
 *
 * For example, the following code combines the URIs of all images and videos
 * into the same column.
 *
 * \code
RDFVariable image = RDFVariable::fromType<nfo::Image>();
RDFVariable video = RDFVariable::fromType<nfo::Video>();

RDFVariable imageOrVideo("imageOrVideo");
imageOrVideo.unionMerge(RDFVariableList() << image << video);

RDFSelect select;
select.addColumn("ImgAndVid", imageOrVideo);
 * \endcode
 * Corresponding SPARQL:
 * \code
{
	# imageOrVideo
	{
		# video
		?imageOrVideo a nfo:Image
	} UNION
	{
		# image
		?imageOrVideo a nfo:Video
	}
}
 * \endcode
 *
 *
 * What happens under the cover is that a new child \ref RDFPattern or
 * \a union \pattern is created to the pattern of imageOrVideo variable for
 * each parameter variable (\a image and \a video in this case). These
 * patterns are placed into union relationship with each other. Then a new
 * \a union \a alias \a variable of the imageOrVideo variable is created
 * into each of these patterns. Lastly, each such variable is then aliased
 * with the respective parameter variable. Thus if the constraints of these
 * variables were not yet connected to the parent variable, these constraints
 * are then merged with their respective union patterns.
 *
 * The flip side of the same coin is to get the list of \a union \a alias
 * \a variables belonging to their respective \a union \a patterns directly
 * instead of any merging, by calling \ref RDFVariable::unionChildren.
 * These union patterns are initially empty, and the user has to insert new
 * constraints into them through the returned varaibles, or otherwise they
 * wont be visible.
 *
 * For example, the following code uses a union to combine e-mail addresses and
 * phone numbers into the same column.
 *
 * \code
RDFVariable contact = RDFVariable::fromType<nco::Contact>("contact");
RDFVariable contact_info("contactInfo");
RDFVariableList contact_info_union_aliases = contactInfo.unionChildren(2);

contact_info_union_aliases[0].subject<nco::hasPhoneNumber>(contact);
contact_info_union_aliases[1].subject<nco::hasEmailAddress>(contact);

RDFSelect select;
select.addColumn(contact);
select.addColumn(contact_info);
 * \endcode
 * Corresponding SPARQL:
 * \code
RDFSelect ?contact ?contact_info
{
	# contact
	?contact a nco:Contact
	{
		# contact_info
		{
			# contact_info_union_aliases[0]
			?contact nco:hasPhoneNumber ?contact_info
		} UNION
		{
			# contact_info_union_aliases[1]
			?contact nco:hasEmailAddress ?contact_info
		}
	}
}
 * \endcode
 *
 *	\subsection user_manual_unbound_rdffilter RDFFilter
 *
 *	\subsection user_manual_unbound_rdffilter_nonexistent Selecting for a non-existent property
 *		In some cases you wish to receive all resources which dont have a
 *	specific property set. In these cases, we use \ref RDFVariable::optional()
 *	and \ref RDFVariable::doesntExist together.
 *	\code
RDFVariable music = RDFVariable::fromType<nmm::MusicPiece>("music");

RDFVariable usage = music.optional().property<nie::usageCounter>(RDFVariable("usage"));
usage.doesntExist();
 * \endcode
 * Corresponding SPARQL:
 * \code
{
	# music
	?music a nmm:MusicPiece
	OPTIONAL
	{
		# music.optional(), usage
		?music nie:usageCounter ?usage
	}
	FILTER(!bound(?usage))

}
 * \endcode
 *	If we did not use optional, we would limit "music" to contain resources which have
 *	the property, after which calling doesntExist would filter everything out.
 *	We can add other filter conditions, if we want to select for music with
 *  usageCounter of 0 as well.
 *	\code
usage.doesntExist().or_(usage.equal(LiteralValue(0)));
// or
usage.doesntExist() || (usage == LiteralValue(0));
 * Corresponding SPARQL:
 * \code
FILTER(!bound(?usage) | ?usage == 0)
 * \endcode
 *
 *
 *	\subsection user_manual_unbound_rdfselect RDFSelect
 *
 * \subsection user_manual_unbound_rdfselect_aggregate Aggregate Columns
 *

 * Aggregates (count, sum, average, minimum and maximum) of RDFVariables can
 * be added to the RDFSelect. To add an aggregate of an existing RDFVariable,
 * use the functions RDFSelect::addCountColumn(), RDFSelect::addSumColumn(),
 * RDFSelect::addAvgColumn(), RDFSelect::addMinColumn() and
 * RDFSelect::addMaxColumn(). To create an aggregate column and the associated
 * RDFVariable at the same time, use the functions
 * RDFSelect::newCountColumn(), RDFSelect::newSumColumn(),
 * RDFSelect::newAvgColumn(), RDFSelect::newMinColumn() and
 * RDFSelect::newMaxColumn().
 *
 * Typically, you also need to specify from which RDFVariable the
 * aggregate is computed. For example, to query the count of replies for each
 * e-mail, you must group the replies for each e-mail. This can be done with
 * the function RDFSelect::groupBy().
 *
 * For example, the following code queries the number of replies for each e-mail.
\code
RDFVariable original = RDFVariable::fromType<nmo::Email>();
RDFVariable reply = RDFVariable::fromType<nmo::Email>();
reply.property<nmo::inReplyTo>(original.optional());

RDFSelect select;
select.addColumn("email", original);
select.addCountColumn("no of replies", reply);
select.groupBy(original);
 * \endcode
 *
 *  \subsection user_manual_unbound_rdfselect_function Function Columns
 *
 * Function columns (also known as property functions) can be used for making
 * a query with optional columns more efficient.
 *
 * For example, the following code queries the IRIs of all contacts. For each
 * contact, it also queries the full name, if it exists. The
 * RDFVariable::optional() is used for including contacts both with and without
 * the full name.
 *
 *  \code
 RDFVariable contact = RDFVariable::fromType<nco::PersonContact>();
 RDFVariable fullName;

 // Create a connection between the RDFVariables contact and fullName. The
 // connection is optional; we also want to retrieve contacts without a full
 // name.
 contact.optional().property<nco::fullname>(fullName);

 RDFSelect select;
 select.addColumn("iri", contact);
 select.addColumn("full name", fullName);
 * \endcode
 *
 * The same results can be achieved by using function columns. For example, the
 * previous code would be transformed into the following:
 * \code
 RDFVariable contact = RDFVariable::fromType<nco::PersonContact>();

 RDFSelect select;
 select.addColumn("iri", contact);
 select.addColumn("full name", contact.function<nco::fullname>());
 *  \endcode
 *
 * \subsection user_manual_unbound_group_concat Group Concatenation
 *
 * Some concepts in the ontology are in a one-to-many relationship, e.g., a
 * contact can have multiple e-mail addresses. If you use the following code
 * to query all contacts and their e-mail addresses, you get multiple rows for
 * the same contact.
 *
 * \code
RDFVariable contact = RDFVariable::fromType<nco::Contact>();
RDFVariable email = contact.property<nco::hasEmailAddress>();

RDFSelect select;
select.addColumn("contact", contact);
select.addColumn("email", email);

LiveNodes model = ::tracker()->modelQuery(select);
 * \endcode
 *
 * If you want only one row per contact, you must use group concatenation to
 * combine all e-mail addresses to a single column. The following code
 * combines the e-mail addresses of each contact (using comma as a separator)
 * and puts them into a single column.
 *
 * \code
RDFVariable contact = RDFVariable::fromType<nco::Contact>();

RDFSelect select;
select.addColumn("contact", contact);
// Add a column which contains all e-mail addresses
select.addColumn(contact.property<nco::hasEmailAddress>().filter("GROUP_CONCAT", LiteralValue(",")));
// Group by the contact -> we get one row per contact
select.groupBy(contact);

LiveNodes model = ::tracker()->modelQuery(select);
 * \endcode
 *
 * \subsection user_manual_unbound_coalesce Coalesce
 * The tracker:coalesce filter accepts a variable number of arguments and returns the first bound value.
 *
 * \code
RDFSelect select;
RDFVariable full, nickname;
RDFVariable c = RDFVariable::fromType<nco::IMContact>();
c.optional().property<nco::fullname>(full);
c.optional().property<nco::nickname>(nickname);
RDFFilter coalesce = full.filter("tracker:coalesce", RDFVariableList()
                << nickname << LiteralValue("none of the previous had value"));
select.addColumn("coalesce", coalesce);
 * \endcode
 *
 * \subsection user_manual_unbound_rdfsubselect RDFSubSelect
 *
 * There are two kinds of subqueries: expression subqueries and inner subqueries.
 *
 * Expression subqueries are used when you want to add a column to your query,
 * and the content of the column is so complex that you need a separate query
 * for it. It is more efficient to add the complex data as a subquery than to
 * execute two queries (one for getting all the rows, and one for querying the
 * complex data for each row).
 *
 * For example, the following code queries all contacts, and for each contact,
 * the latest received message from that contact.
 *
 * \code
RDFSelect outerSelect;
RDFVariable contact = RDFVariable::fromType<nco::Contact>();
outerSelect.addColumn("contact", contact);

RDFSubSelect innerSelect;
RDFVariable email = innerSelect.newColumn("email");
RDFVariable date;
email.property<nmo::from>(contact);
email.property<nmo::receivedDate>(date);
innerSelect.orderBy(date, RDFSelect::Descending);

outerSelect.addColumn(innerSelect.asExpression());

LiveNodes model = ::tracker()->modelQuery(outerSelect);
 * \endcode
 *
 * The function RDFSubSelect::asExpression() formulates the inner query as an
 * expression which can then be added as a column with RDFSelect::addColumn().
 *
 * To insert restrictions to the subquery, you need to create instances of variables which live
 * inside the subquery. Than can be done by using RDFSelect::variable().

 * For example, the following code uses an expression subquery for selecting the artist count for a
 * music album.

\code
RDFVariable album = RDFVariable::fromType<nmm::MusicAlbum>();
RDFSelect select;
select.addColumn("album uri", album);

RDFSubSelect subSelect;
// These restrictions are supposed to go inside the subselect; use subselect.variable(album) to
// create an instance of the album variable which lives inside the subquery.
RDFVariable inner_song = subSelect.variable(album).subject<nmm::musicAlbum>();
RDFVariable inner_artist = inner_song.optional().property<nmm::performer>();
subSelect.addCountDistinctColumn(inner_artist);
subSelect.groupBy(album);

select.addColumn(subSelect.asExpression());
\endcode

 * An expression subquery is used for adding a column to the result set. Inner
 * subqueries are used for declaring compex restrictions on the variables used
 * in the query.
 *
 * For example, the following code uses an inner subquery to select two oldest
 * contacts, and then retrieves all e-mail messages sent by those two
 * contacts.
 *
 * \code
RDFSelect outerSelect;
// These restrictions go to the outer select
RDFVariable contact = outerSelect.newColumn();
RDFVariable message = outerSelect.newColumn<nmo::Message>();
message.property<nmo::from>(contact);

RDFSubSelect innerSelect;
// The "contact" in the inner select is the same as the "contact" in the
// outer select
RDFVariable innerContact = innerSelect.newColumnAs(contact);
// These restrictions go to the inner select
RDFVariable date = innerContact.property<nco::birthDate>();
innerSelect.orderBy(date);
innerSelect.limit(2);

LiveNodes model = ::tracker()->modelQuery(outerSelect);
 * \endcode
 *
 * The limitation applied to the inner query guarantees that we get at most
 * two contacts, but it does not limit the total number of rows. Also, the
 * ordering by birth date applies only to the inner query; the result set is
 * returned in the default order (URIs of contacts).
 *
 * The outer and inner query share the RDFVariable contact; it appears as a
 * column in both queries. To declare that the outer and inner query refer to
 * the same contact, the column in the inner query is created with
 * RDFSelect::newColumnAs(), giving as a parameter the RDFVariable associated
 * with the outer query.
 *
 * The RDFVariable date appears only in the inner query. It is not added as a
 * column, but only used for ordering the query results.
 *
 *	\subsection user_manual_unbound_rdfupdate RDFUpdate
 *
 *  \subsection user_manual_unbound_rdfproperty RDFProperty
 *
 *    RDFProperty describes an {RDFVariable predicate, RDFVariable subject}
 *  or {RDFVariable predicate, RDFVariable object} pair. It is used to
 *  describe a single graph traversal step from one resource node set to
 *  another across a property relationship edge. RDFProperty thus contains
 *  the edge information as the predicate, but also the direction in which the edge
 *  should be taken. As the predicate and subject/object are RDFVariable's,
 *  they can contain arbitrary further limitations describing the traversal.
 *	\code
RDFVariable email = RDFVariable::fromType<nmo::Email>();
RDFPropertyList props;
props
  << RDFProperty::fromObjectOf<nmo::recipient>()
  << RDFProperty::fromObjectOf<nco::fullname>();
RDFVariable fullnames = RDFProperty::traverse(email, props);
 *	\endcode
 *
 *  \subsection user_manual_unbound_graphs Graphs
 *
 *    Triples inside an RDF service are arranged in graphs. Each graph can contain a separate
 *  set of triples, but by default all triples in all graphs in the service are accessed when
 *  making a query. When making queries, individual statements can be constrained to only
 *  certain graphs, or the source graph of a statement can be fetched by using
 *  \ref RDFVariable::inGraph and \ref RDFPattern::graph functions.
 *
 *  By default when new RDF statements are inserted into the service, they are inserted
 *  into the unnamed default graph. The statements can be explicitly inserted to specific graph
 *  by using RDFUpdate::addInsertion.
 *  \code
 *
	// industrial
	RDFServicePtr svc = getMyService();
	QUrl graph_url("http://graphurl.com/#1");
	RDFUpdate up;

	svc.executeQuery(RDFUpdate().addInsertion
			( RDFStatementList()
					<< RDFStatement
							( QUrl("http://res.com/#1"), rdf::type::iri(), rdfs::Resource::iri())
					<< RDFStatement
							( QUrl("http://res.com/#1"), nco::note::iri(), LiteralValue("note"))
			, graph_url);


	{
		RDFVariable contacts_var = RDFVariable::fromType<nco::Contact>();
		LiveNodes res = ::tracker()->modelVariables(RDFVariableList()
				<< contacts_var
				<< contacts_var.object<nco::note>()
				<< contacts_var.pattern().graph());
		// retrieves contacts, the note associated and the source graph containing these
	}

	{
		RDFVariable contacts_var = RDFVariable::fromType<nco::Contact>();
		LiveNodes res = ::tracker()->modelVariables(RDFVariableList()
				<< contacts_var
				<< contacts_var.inGraph(graph_url).object<nco::note>());
		// retrieves contacts having a note inside graph identified by graph1_url
	}
 *  \endcode
 *
 *  \subsection user_manual_unbound_graphs Graphs and Tracker
 *
 *    Tracker supports only one graph per triple, and per single-valued property.
 *
 *
 *  \subsection user_manual_unbound_derived Derived properties
 *
 *    Derived properties represent data dependency relationships. Suppose we
 *  query for all e-mails received today and their subjects. The e-mail and
 *  date depend on each other, as we can't know which e-mails to pick without
 *  knowing the dates, and we can't know the dates without knowing the
 *  e-mails. This basic set of data is primary data. However, this primary
 *  data set clearly doesn't depend on the subjects of the e-mails. The
 *  subjects can be anything without affecting which e-mail/date combinations
 *  are picked. These kind of properties are called derived properties.
 *  SopranoLive relies on derived properties when implementing client side
 *  live queries.
 *
 *
 *	\subsection user_manual_unbound_sparql SPARQL
 *
 *	\subsection user_manual_unbound_with_qt With Qt and Soprano
 *
 *
 *
 *
 *	\section user_manual_bound 6. Bound World
 *
 *	  The bound world contains the objects which know their originating backend service and their graph in it. These objects \ref LiveResource, and \ref LiveNodeModel, and their convenience by-value classes, LiveNode and LiveNodes. They represent a single resource and a set of resources, respectively.
 *
 *	\subsection user_manual_bound_livenode 6.1. LiveNode and LiveResource
 *
 *	  \ref LiveResource is a by-reference abstract interface which handles the access to the resource in a graph. It is implemented by the backend which contains the graph.
 *	  \ref LiveNode is a concrete by-value convenience class which manages the LiveResource through a shared pointer. It also imitates Soprano::Node and offers tools to obtain the identity of the resource.
 *
 *  \subsection user_manual_bound_livenode_strict 6.1.1. Managing a Single Resource: strict vs. non-strict approaches
 *
 *	  When managing a resource there are two general approaches: strict and non-strict.
 *	  The strict approach means that no changes to the backend are made but any requested qualities are verified, and if these requirements aren't satisfied, a null entity is returned. Conversely, with non-strict approach these qualities are created if they dont exist.
 *
 *	  Two strict examples:
 *	\code
 *	LiveNode node = graph->strictLiveNode(qurl);
 *	StrictLive<nco::Contact> contact = node;
 *	\endcode
 *
 *	  In the first line with strictLiveNode, the quality being checked is "this resource exists" and \ref strictLiveNode returns a null livenode if the resource doesnt exist in the graph.
 *	  In the second line with StrictLive<nco::Contact> on assignment, the quality is "this resource has type nco:Contact". If the node doesn't have this type, the assignment sets the contact to null.
 *	  In the end, \a node is live resource if it already existed in the graph. \a contact is live only if the resource exists and also had the nco:Contact type.
 *
 *    The same with a non-strict approach:
 *	\code
 *	LiveNode node = graph->liveNode(qurl);
 *	Live<nco::Contact> contact = node;
 *	\endcode
 *
 *	  In the first line with liveNode, the quality "this resource exists" is asserted and resource \a qurl is created if it doesnt exist.
 *	  In the second line with Live<nco::Contact> on assignment, the quality "this resource has type nco:Contact" is asserted and the type is added.
 *	  In any case, in the end both \a node and \a contact are valid and live.
 *
 *	  The approaches can be mixed:
 *	\code
 *	Live<nco::Contact> contact = graph->strictLiveNode(qurl);
 *	\endcode
 *	  This strictly checks if the resource \a qurl exists, if not, returns and sets \a contact to null. If the resource exists, the type nco:Contact is non-strictly added to it and \a contact is live.
 *
 *	  The choices between the approaches are usually obvious from the required semantics. Performance wise, the strict approach might mean a blocking query roundtrip to the backend, if the quality doesnt happen to be cached. Non-strict approaches typically dont block, but the resulting creation of the quality might still put some load on the backend.
 *
 *	  Industrialist knows that in RDF terms, "resource <qurl:0> exists" means that the triple "<qurl:0> a rdfs:Resource" exists in the graph, where rdfs:Resource is the ultimate base class. Similarily, "resource <qurl:0> has type nco:Contact" means that the triple "<qurl:0> a nco:Contact" exists in the graph.
 *
 *	\subsection user_manual_bound_livenodes 6.2. LiveNodes and LiveNodeModel
 *
 *		LiveNodeModel is a model as defined by the Qt model/view architecture. It is the central and most elaborate structure in SopranoLive. LiveNodes is a by-value convenience class that performs the memory management and some services for LiveNodeModel.
 *
 *	\subsection user_manual_bound_livenodes_dummy 6.2.1. Obtaining an empty, writable local model
 *
 *		LiveNodeModel objects cannot be directly instantiated. In some cases however it is desirable to obtain an empty, local model and write data to it without causing any external accesses. A typical scenario is when creating test cases. We use the \ref user_manual_backends_local to obtain ourselves one such model.
 *	\code
 *	// note that we still want to specify the columns with their appropriate types.
 *	LiveNodes model = BackEnds::Local::service()->modelVariable(RDFVariable::fromType<rdfs::Resource>("column name"));
 *	// insertRows which takes a QList<LiveNode> as argument can be used to initialize the first column of items.
 *	model->insertRows(0, LiveNodeList() << test_uri1 << test_uri2);
 *	\endcode
 *
 *	\subsection user_manual_bound_livenodes_optionals 6.2.2. Optional columns and null data
 *
 *		If a model column represents an optional variable, retrieving a live node via liveNode(row, col) will return a null LiveNode if the optional value doesn't exist.
 *	\code
 *	RDFVariable res = RDFVariable::fromType<nfo::MediaList>("media");
 *	LiveNodes model = BackEnds::Local::service()->modelVariables(RDFVariableList() << res << res.optional.property<nfo::fileLastAccessed>());
 *	for(int row = 0, rowend = model->rowCount(); row != rowend; ++row)
 *	{
 *		// this is always valid, we know that
 *		qDebug() << model->liveNode(row, 0).toString();
 *		// an optional value might not be bound. Calling toString() would
 *		// return an empty string and not crash, but we want a special message
 *		if(LiveNode last_access = model->liveNode(row, 1))
 *			qDebug() << last_access.toString();
 *		else
 *			qDebug() << "never accessed";
 *	}
 *	\endcode
 *
 *	\subsection user_manual_bound_livenodes_strategies 6.2.3. Model strategies
 *
 *	  The behaviour of a LiveNodeModel can be customized by \ref RDFStrategyFlags which are
 *	  listed in enum \ref RDFStrategy. All functions and pathways resulting in LiveNodeModel
 *	  offer a method for requesting the initial strategy, typically as a parameter for the
 *	  function returning the model.
 *
 *	  \n \n In addition to requesting an initial strategy, the strategy of the existing model can
 *	  be retrieved and changed with \ref LiveNodeModel::strategy and
 *	  \ref LiveNodeModel::alterStrategy respectively. The range of allowed state changes on an
 *	  existing model is typically more limited than on the initial request.
 *
 *	  \sa LiveResource::getObjects, RDFGraph::modelQuery, RDFProperty, RDFVariable::addDerivedProperty
 *
 *	\subsection user_manual_bound_livenodes_streaming 6.2.3.1 RDFStrategy::Streaming
 *
 *	  When a model is in a streaming state, the result set is built incrementally by retrieving
 *	  consequtive blocks, and this is useful for managing large and partial data sets. Updates are
 *	  indicated by emitting QAbstractItemModel signals. The model rowCount reflects the current number
 *	  of rows, and accessing model data on a region that has not yet been retrieved will fail.
 *
 *	  Streaming has two associated model states: RDFStrategy::Streaming and RDFStrategy::Running.
 *	  When RDFStrategy::Running is enabled, a block is being retrieved. When Streaming is enabled,
 *	  and a block finishes, next block will be automatically initiated. Otherwise, if a block
 *	  finishes while Streaming is disabled, no new streaming block will be retrieved, and
 *	  RDFStrategy::Running will be disabled. The next block must be manually initiated by either
 *	  enabling RDFStrategy::Running, or by calling \ref QAbstractItemModel::fetchMore.
 *
 *	  The service attributes "streaming_block_size", "streaming_first_block_size", and
 *	  "streaming_limit" control the parameters of streaming. "streaming_first_block_size"
 *	  determines the size of the first block of the stream, and "streaming_block_size" determines
 *	  the size of the subsequent blocks. "streaming_limit" controls the duration of automatic
 *	  streaming. Once the limit is reached, RDFStrategy::Streaming is automatically turned off.
 *	  The RDFSelect::getLimit method returns this value when the query is first run, but the value
 *	  can be programatically changed or disabled later.
 *
 *	  SopranoLive offers generic streaming using SPARQL filters and limit, but requires that
 *	  each row has an unique ordering as specified by orderBy on existing column variables.
 *	  The easiest way to do this is to add an orderBy clause on some resource column. Backends might
 *	  offer specific streaming solutions with different requirements.
 *
 *
 *	  \code
// Main User: Industrialist
{
	RDFSelect email_sel;
	RDFVariable emails = email_sel.newColumn<nmo::Email>();
	email_sel.orderBy(emails.property<nmo::sentDate>(), RDFSelect::Descending);
	email_sel.orderBy(emails); // add email resource column to ensure the ordering is unique
	email_sel.limit(400); // limit automatic streaming. Becomes "streaming_limit" for the model.

	::tracker()->setServiceAttribute("streaming_first_block_size", QVariant(20));
	::tracker()->setServiceAttribute("streaming_block_size", QVariant(200));
	LiveNodes emails = ::tracker()->modelQuery(email_sel, RDFStrategy::DefaultStrategy | RDFStrategy::Streaming);

	// the query is then done in three parts, retrieving 20, 200 and 180 rows respectively.
	// after this the streaming must be re-enabled with fetchMore();

	timeTakingComputationDuringWhichAutomaticStreamingFinishes();

	// disable the limit, get all remaining content using a canFetchMore/fetchMore cycle.
	// Decrease block size too, because fetchMore doesn't enable automatic streaming,
	// but only retrieves a single block at a time.
	emails->setModelAttribute("streaming_limit", QVariant(RDFSelect::NoLimit));
	emails->setModelAttribute("streaming_block_size", QVariant(50));
	if(emails->canFetchmore())
		emails->fetchMore();
}

// Main User: Transcendental
{
	RDFVariable emails = RDFVariabel::fromType<nmo::Email>();

	emails.addDerivedObject<nmo::sentDate>
			(RDFStrategy::HiddenColumn | RDFStrategy::Descending);

	LiveNodes emails = ::tracker()->modelVariable
			(emails, RDFStrategy::DefaultStrategy | RDFStrategy::Streaming);
	// streaming state and parameter management is the same as for Industrialist.
}
 *	  \endcode
 *
 *
 *	\subsection user_manual_bound_livenodes_windowed 6.2.3.2 RDFStrategy::Windowed
 *	\subsection user_manual_bound_livenodes_live 6.2.3.3 RDFStrategy::Live
 *
 *	  A live query is a query operation whose result set is updated when data in the queried
 *	  graph changes. In its simplest, a regular RDFSelect query is made live by passing the
 *	  RDFStrategy::LiveStrategy flag for the RDFGraph::modelQuery function:
 *	\code
	// create query for all feed messages
 	RDFVariable messages_var = RDFVariable::fromType<mfo::FeedMessage>();
	RDFSelect sel;
	sel.addColumn("messages", messages_var);

	// model the query is a live query
	LiveNodes result = graph()->modelQuery(sel, RDFStrategy::LiveStrategy);

	// connect to the updates for the query
	connect(result.model(), SIGNAL(rowsInserted(const QModelIndex &, int, int))
		, this, SLOT(reactToRowInsertion(const QModelIndex &, int, int)));
	connect(result.model(), SIGNAL(rowsRemoved(const QModelIndex &, int, int))
		, this, SLOT(reactToRowInsertion(const QModelIndex &, int, int)));
 *	\endcode
 *	  A live query can naturally have multiple columns like a regular query. When resources in
 *	  any of these columns are created or destroyed, data in the result model will get updated to
 *	  reflect these changes. These changes are then signaled using the standard QAbstractItemModel
 *	  signals. These updates emit appropriate QAbstractItemModel row insertion, deletion and
 *	  changed signals. The nature of the updates depends on \a primary and \a derived \a columns,
 *	  and the ordering criteria of the query.
 *
 *	\subsection user_manual_bound_livenodes_live_derived_properties 6.2.3.3.1 RDFStrategy::Live and derived properties
 *
 *	  When a regular query is made live, all the columns are treated as equals. We'll call
 *	  them \a primary \a columns. The only update operations are row insertion and removal.
 *	  However, in most cases not all data in the result set is equal. Say we're querying for
 *	  images and their last modified date. When an image is created or destroyed, the respective
 *	  row in the result should obviously be created or destroyed as well. But if the last
 *	  modified date of an image changes, the row should not be destroyed, only changed.
 *	  We say that the last modified date is a \a derived \a property of the image.
 *	  We would make such a query like follows:
 *	\code
	RDFVariable image = RDFVariable::fromType<nmm::Photo>();
	// declare that we're interested in the nao:lastModified of the image as a derived property
	// (note that the function is called addDerivedObject, not addDerivedProperty, for now)
	image.addDerivedObject<nao::lastModified>();
	RDFSelect sel;
	sel.addColumn(image);
	LiveNodeModelPtr res = graph()->modelQuery(sel, RDFStrategy::LiveStrategy);
 *	\endcode
 *	  \n \n \a Primary \a columns are all columns which are manually added to the query.
 *	  \n The \a identity \a columns of a row is determined by the column variables specified as
 *	  RDFStrategy::IdentityColumn. If these flags are not specified, all primary columns are
 *	  treated as identity columns.
 *	  \n When data in an identity column is added or deleted, appropriate row insertion and removal
 *	  signals are emitted. Identity column data is never changed, only added or deleted.
 *	  \n When data in a non-ordered single-valued non-identity column changes, appropriate
 *	  data change signals are emitted.
 *	  \n When data in an ordered non-identity column changes, appropriate row move signals are
 *	  emitted. (note: tracker backend implements this still as row deletion and insertion).
 *	  \n \a Derived \a columns are all columns recursively expanded from the derived properties
 *	  of all previous primary and derived columns of the query. A derived column can never be
 *	  an identity column
 *
 *	  We can specify an ordering for a resource based on some derived single-valued property,
 *	  by passing RDFStrategy::Ascending or RDFStrategy::Descending to addDerivedObject:
 *	  \code

	// getting all FeedMessage objects
 	RDFVariable messages_var = RDFVariable::fromType<mfo::FeedMessage>();
	messages_var.addDerivedObject<dc::title>
			(RDFVariable("title"), RDFStrategy::Ascending | RDFStrategy::DefaultStrategy);

 	RDFVariable recipients_var = messages_var.object<nmo::to>();

 	RDFVariable emailaddress_var = recipients_var.addDerivedObject<nmo::hasEmailAddress>();
 	emailaddress_var.addDerivedObject<nmo::emailAddress>
			(RDFVariable("address"), RDFStrategy::Ascending | RDFStrategy::DefaultStrategy);

	RDFSelect sel;
	sel.addColumn("message", messages_var);
	sel.addColumn("recipient", recipients_var);

	RDFServicePtr backend = getBackend();
	LiveNodes res = backend->modelQuery(sel, RDFStrategy::LiveStrategy);

	connect( res.model(), SIGNAL(dataChanged(const QModelIndex &, const QModelIndex &))
	       , this, SLOT(myDataChangedSlot()));
	connect( res.model(), SIGNAL(rowsInserted(const QModelIndex &, int, int))
	       , this, SLOT(myRowsInsertedSlot()));
	connect( res.model(), SIGNAL(rowsRemoved(const QModelIndex &, int, int))
	       , this, SLOT(myRowsRemovedSlot()));

 *	  \endcode
 *	\subsection user_manual_bound_livenodes_live_tracker 6.2.3.3.2 RDFStrategy::Live and Tracker
 *
 *	  Tracker signals changes through classes which have tracker:notify set to true. This means
 *	  that the variable representing a column must be associated with a class with
 *	  tracker:notify true to get live updates for it. Most of the time this happens automatically
 *	  when RDFVariable::fromType and RDFVariable::isOfType functions are used to build the actual
 *	  query, like in the above example. The only column is associated with \a messages_var, which
 *	  has the type mfo:FeedMessage, which has the property tracker:notify as true.
 *
 *	  To see when this is not the case, we will have to understand how tracker update signals work.
 *	  The essential point is that tracker:notify is enabled only for leaf or (near) leaf types in
 *	  the inheritance tree. This is for performance reasons: idea is that is that applications can
 *	  submit to notifications for resources only in their own domain. They then avoid having to
 *	  wake up when data they are not interested in changes.
 *
 *	  Sometimes you might want to make a query for a wider range of resources however. For
 *	  example, if we want all nmm:Photo and nmm:Video resources, we can have an efficient query by
 *	  querying for their base class, nmm:Visual. But nmm:Visual doesn't have notifications
 *	  enabled, so we need to give the tracker backend hints on these signaling types. We use
 *	  RDFVariable::isOfType with a specific flag to denote that the variable \a might have this
 *	  type, without affecting the query itself.
 *	\code
	RDFVariable visuals_var = RDFVariable::fromType<nmm::Visual>();
	// add a hint that visuals_var might have the types nmm:Photo and nmm:Video
	// without actually constraining the query.
	visuals_var.isOfType<nmm::Photo>(false, RDFStrategy::DerivedProperty);
	visuals_var.isOfType<nmm::Video>(false, RDFStrategy::DerivedProperty);
 *	\endcode
 *
 *   The next example shows how to create a live query containing feed messages, which gets
 * updated if a title of some feed channel changes. A bit more indirection is needed here:
 * a message is connected to its channel with nie:isLogicalPartOf, and each channel can
 * have a nie:title. Also, qttracker needs to watch two classes (nmo:FeedMessage and
 * nmo:FeedChannel) for changes, and this information needs to be given to it.
 *	\code
    // This is the "base" class to watch; the model will contain messages and
    // information from them. Here you need to declare the type of the variable,
    // so that qttracker will know which classes to watch (the update signals
    // from tracker are per-class).
    RDFVariable message = RDFVariable::fromType<mfo::FeedMessage>();

    // addDerivedObject(): When the isRead property changes for some message,
    // the model is updated. Also, the model automatically contains a column for
    // the "isRead" property; don't add it manually!
    message.addDerivedObject<nmo::isRead>();

    // Here you need to declare the type of the variable, so that qttracker
    // will know which classes to watch (the update signals from tracker are
    // per-class).
    RDFVariable channel = RDFVariable::fromType<mfo::FeedChannel>();

    // Then you declare that the model needs to be update when the channel
    // changes. However, you also want to add the channel as a real column to
    // the model. You don't want it to get added automatically, since
    // nie:isLogicalPartOf is a multi-valued property, so it would be added as a
    // separate submodel.
    // Note: use derivedObject(), not object(), and not addDerivedObject() !
    message.derivedObject<nie::isLogicalPartOf>(channel);

    // The title is just a normal derived object of the channel; when the title
    // changes, the model needs to be udpated. The column will be added
    // automatically to the model.
    channel.addDerivedObject<nie::title>();

    RDFSelect select;
    select.addColumn(message);
    // Here we add the channel manually to the query
    select.addColumn(channel);
    LiveNodes nodes = ::tracker()->modelQuery(select, RDFStrategy::LiveStrategy);
 *	\endcode
 *	\subsection user_manual_bound_livenodes_live_update_properties 6.2.3.3.3 RDFStrategy::Live and derived update properties
 *
 *	  By default in a live query only derived property changes get updated when remote data
 *	changes. But often a column has constraints that are not connected to other columns, or has
 *	connections between primary columns like below:
\code
        RDFVariable image = RDFVariable::fromType<nmm::Photo>();
        image.property<nao::lastModified>().greater(someDate()); // we add a constraint, but it is not live
        LiveNodeModelPtr res = graph()->modelVariable(image, RDFStrategy::LiveStrategy);
\endcode
 *
 *	But because they are constraints nonetheless, remote changes to these properties might
 *	change the query results, and should thus be reflected in the model. Qttracker query builder
 *	is limited in introspection and this information cannot be deduced from the query. This is why
 *	these update dependencies must be explicitly specified by using addUpdateProperty function.
 *
\code
        RDFVariable image = RDFVariable::fromType<nmm::Photo>();
        image.property<nao::lastModified>() > someDate();
		image.addUpdateProperty<nao::lastModified>(); // image is observed for changes in
		                                              // nao:lastModified property
        LiveNodeModelPtr res = graph()->modelVariable(image, RDFStrategy::LiveStrategy);
\endcode
 *
 *	\subsection user_manual_bound_livenodes_writable 6.2.3.4 RDFStrategy::Writable
 *	\subsection user_manual_bound_livenodes_cached 6.2.3.5 RDFStrategy::Cached
 *
 *	  When a model is in a Cached state, all derived property information is reflected inside a
 *	  graph cache. When a property request through any LiveNode object resource belonging to
 *	  this graph is made, all cached model contents of the graph are checked to see if any of
 *	  them contains the requested property data. If the data can be found from the cache, it
 *	  is returned directly, otherwise the request proceeds to the backend. The cache association
 *	  between the model and the graph is tight: the model \a directly makes up part of the cache.
 *	  Any updates on the model directly affect data retrieved from the cache. If the model is
 *	  destroyed or cleared, the contents disappear from the cache.
 *	  \n RDFStrategy::BypassCache and RDFStrategy::UseOnlyCache flags can be used to bypass cache
 *	  to access the backend directly, and to only access cached information, respectively.
 *
 *	  Only derived property information is stored inside the cache. A plain hand-crafted query
 *	  will not contain any cached information. Only LiveNode based property accesses use the
 *	  cache. Making the same RDFSelect query again will always access the backend.
 *
 *	\subsection user_manual_bound_livenodes_from_uris 6.2.4 Constructing a LiveNodes from a list of resources

 * With the functions RDFGraph::liveNodes() and RDFGraph::strictLiveNodes() you can obtain a
 * LiveNodes model consisting of the specified LiveNode resources.

 * The non-strict function RDFGraph::liveNodes() ensures that the given resources have the same
 * type(s) as the RDFVariable object_info provided, by inserting missing types if necessary.

 * The strict function RDFGraph::strictLiveNodes() includes in the returned model only those
 * resources which have the same type(s) as the provided RDFVariable object_info.

 * The single-valued derived properties of the provided RDFVariable object_info will be added as
 * columns to the returned LiveNodes model.

 * Note: The ordering of the returned model and handling the possible duplicates in the given
 * LiveNodeList is not yet implemented, and the behavior of the function regarding these might
 * change in the future. The current implementation does not make any guarantees about the ordering
 * of the rows in the returned LiveNodes model. The ordering might even differ between two
 * successive calls with the same parameters.

\code
// Get a big model containing lots of e-mails
LiveNodes big_model = ::tracker()->modelQuery(some_query);

// The user selects only a couple of them
LiveNodeList selected_emails;
// Let's imagine the user has selected these
selected_emails << "emailuri1" << "emailuri2" << "emailuri3";
RDFVariable object_info = RDFVariable::fromType<nmo::Email>();
object_info.addDerivedObject<nmo::isRecent>();
object_info.addDerivedObject<nmo::isAnswered>();

// Get a model containing only those 3 e-mails.
LiveNodes small_model = ::tracker()->strictLiveNodes(selected_emails, object_info);

// The big model can now be discarded; the small_model contains the relevant e-mails
big_model = LiveNodes();
\endcode


 *	\section user_manual_backends 7. Backends
 *
 *	\subsection user_manual_backends_local 7.1. Local Backend Service
 *
 *	  An unconnected, local service. The majority of services offered work as
 *	  normal, except that queries will always return empty result sets.
 *	  Useful for dummy testing purposes.
 *
 *	\subsection user_manual_backends_tracker 7.2. Tracker
 *
 *	\section user_manual_ontologies 8. Ontologies
 *
 *	  Ontologies specify the classes and properties (and much more) of
 *	  some conceptual domain in terms of a set of RDF triples.
 *	  If we approach RDF in OO terms, the classes and properties are
 *	  first-class objects themselves in RDF, and an ontology is a set of
 *	  these objects.
 *	  \n Let's take a small refresher on RDF to understand what this means.
 *
 *
 *	\subsection user_manual_ontologies_triples 8.1. Typical Ontology Triples
 *
 *	  \n\n Example 1 - Data triples of an e-mail
 *
 *	  \n\n <urn:uuid:ff6a5de0-d8fd-11de-8a39-0800200c9a66> a nmo:Email ;
 *	  \n 	nmo:messageSubject "Hello world!" .
 *
 *	  These triples are what one ends up manipulating in end user scenarios,
 *	  but rarely appear in ontologies
 *
 *    \see user_manual_ontologies_statics
 *
 *	  \n\n 'a' is a short-hand for rdf:type, meaning the given uri is of type
 *	  nmo:Email. The e-mail also has a subject specified here.
 *
 *	  \n\n Example 2 - Triples describing the types of nmo:Email and nmo:messageSubject
 *
 *	  \n\n nmo:Email a rdf:Class .
 *	  \n\n nmo:messageSubject a rdf:Property .
 *
 *	  \n\n These triples appear in the nmo ontology, which is defined by
 *	  Nepomuk. It turns out that nmo:Email is also an ordinary 'resource' and can
 *	  thus have properties and a type itself. The type of all class
 *	  describing resources is, in fact, rdf:Class. Both nmo:Email and
 *	  nmo:messageSubject have many other properties dictated by the nmo
 *	  ontology which describe the nmo:Email class and the nmo:messageSubject
 *	  property further. It is these properties and the above type triples
 *	  that make up for most of the ontology contents.
 *
 *	  \n\n Finally, let's look at rdf:Class itself.
 *
 *	  \n\n Example 3 - The Triple Describing the Type of rdf:Class
 *
 *	  \n\n rdf:Class a rdf:Class .
 *
 *	  \n\n There you have it, infinite recursion! In retrospect, the above
 *	  triple is obvious: as rdf:Class is the rdf:type of all resources which
 *	  describe types, and it is itself a resource describing a type, so it
 *	  must be its own rdf:type as well. This triple appears in the
 *	  fundamental rdf ontology given to us by W3C. Together with its sister
 *	  ontology, rdfs, they describe the basic classes and properties used to
 *	  describe other ontologies. Once you understand this, you are
 *	  well on the way to understanding RDF. To find a lot of other information
 *	  relating to RDF, start from http://en.wikipedia.org/wiki/RDF_Schema .
 *
 *	\subsection user_manual_ontologies_generation 8.2. Convenience Class Generation
 *
 *	  SopranoLive can generate convenience classes out of RDF ontologies.
 *	  They are plain C++ header-only classes which are used extensively
 *	  with various SopranoLive services.
 *
 *	\section user_manual_ontologies_classes 8.2.1. rdf:Class Convenience Classes
 *
 *	\section user_manual_ontologies_properties 8.2.2. rdf:Property Convenience Classes
 *
 *	\section user_manual_ontologies_constants 8.2.3. Constants, Enumerations and Global Values
 *
 *	  Ontologies sometimes contain global values or enumerations.
 *	  Below is a code example showing how to access them, see how
 *	  nco:default-contact-me (nco::default_contact_me) and nco:gender-female
 *	  (nco::gender_female) are used.
 *	\code
// create new person contact
Live<nco::PersonContact> someone = ::tracker()->createLiveResource<nco::PersonContact>();

// Instead of using nco::default_contact_me , we could actually use
// any generated class here, to get a live node that represents the
// actual reflective class/property info
Live<nco::PersonContact> me = ::tracker()->liveResource<nco::default_contact_me>();

// the ::iri() is a generic way to get a uri out of a generated
// convenience class, we use it here as it works just fine.
someone->setGender(nco::gender_female::iri());

Live<nco::Gender> my_old_gender = me->firstGender();

// we could do this too, and should be as performant as above
// (no queries to backend for getting the nco::gender_female)
me->setGender(::tracker()->liveResource<nco::gender_female>());

// add a group to connect "me" and "someone"
Live<nco::ContactGroup> group = ::tracker()->createLiveResource<nco::ContactGroup>();
me->addBelongsToGroup(group);
someone->addBelongsToGroup(group);

// the unbound counterpart for static resource, "me" is now explicitly
// constrained to nco::default_contact_me
RDFVariable me_var = RDFVariable::fromInstance<nco::default_contact_me>();

RDFVariable all_my_female_contacts = isLocalResource(RDFVariable::fromType<nco::PersonContact>());

// first is the property, second is the value of the property
all_my_female_contacts.property<nco::gender, nco::gender_female>();

// constrain all_my_female_contacts to female contacts belonging to the same group as me
RDFVariable my_groups = me_var.property<nco::belongsToGroup>();
all_my_female_contacts.property<nco::belongsToGroup>(my_groups);
all_my_female_contacts != me_var;

LiveNodes associations = ::tracker()->modelVariable(all_my_female_contacts);
QCOMPARE(associations->rowCount(), 1);
QCOMPARE(associations->liveResource<nco::PersonContact>(0), someone);
 *	\endcode
 *
 * \section user_manual_efficiency_tips 9. Misc and Tips for Efficient Usage
 *
 * Try to use as few queries as possible. If you need to do a query, and then
 * do additional queries based on the results you got, you might be able to
 * use \ref user_manual_unbound_rdfsubselect instead.
 *
 * While developing and debugging, it is useful to set the environment variable
 * QTTRACKER_LOGLEVEL to an integer value (between 0-5) to alter the runtime
 * warning/debug message verbosity level.
 *
 * Avoid RDFVariable::optional(). Try to use \ref user_manual_unbound_rdfselect_function instead.
 *
 *	\section user_manual_future 10. Shortcomings and the Future
 *		SopranoLive is intended to address multiple RDF source data aggregation elegantly, but currently, as only a single local implementation exists, this part is lacking.
 *
 *
 *
 *	\section user_manual_glossary 11. Glossary
 *
 */
}
#endif /* SOPRANOLIVE_DOCUMENT_GLOBAL_H_ */
