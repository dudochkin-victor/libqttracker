/*
 * This file is part of LibQtTracker project
 *
 * Copyright (C) 2009, Nokia
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public License
 * along with this library; see the file COPYING.LIB.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA 02110-1301, USA.
 */
/*
 * rdfunbound.h
 *
 *  Created on: Jan 19, 2009
 *      Author: Iridian Kiiskinen <ext-iridian.kiiskinen at nokia.com>
 */

#ifndef SOPRANOLIVE_RDFUNBOUND_H
#define SOPRANOLIVE_RDFUNBOUND_H

#include "live.h"

namespace SopranoLive
{
	/*!
	 *	\page layer_unbound Query Building with Unbound Services
	 *	Intro snippet: examples/email/email.cpp:
	 *	\code
void EmailViewer::refreshEmails() // select all emails
{
	RDFSelect select;
	select.addColumn("Email_iri", RDFVariable::fromType<nmo::Email>());
	query_model = ::tracker()->modelQuery(select);
	query_view->setModel(query_model.data());
}
	 * \endcode
	 *
	 *	The unbound services revolve around \ref RDFVariable and \ref RDFPattern objects.
	 *	\n RDFVariable is unbound, it which means is has no values.
	 *	\n Instead it represents a set of constraints.
	 *	When these are applied to a concrete graph, we get a set of bound nodes, with all unwanted nodes filtered out by the constraints.
	 *	\n The three main constraint statements are:
	 *	\arg Variable is equal to a literal.
	 *	\arg Variable is equal to another variable.
	 *	\arg Three variables are in a subject-predicate-object relationship.
	 *	\n These constraints can be then grouped under \ref RDFPattern objects, and additional \ref unbound_filters can be given to limit the set.
	 *	Once a desirable set of constrainted variables is created, they are formed in an \ref RDFSelect query.
	 *	This select query then contains the information on how to map an \ref RDFGraph into a table form a \ref LiveNodeModel result set.
	 *
	 *	RDFVariable
	 *	Example code, which selects all emails coming from (\a nmo:from) an unspecified entity with property nco:nameGiven \a name, and then shows the email object id in the first column and the subject text in second column:
	 *	\code
LiveNodes getEmailsFromName(QString name)
{
	RDFVariable email = RDFVariable::fromType<nmo::Email>();
		// "email" is initialized from an RDFVariable which is constrained to all nodes of type nmo:Email.
		// Make use of the autogenerated class nmo::Email.
	RDFVariable sender;
		// Initially, \a sender represents all resources. We know that typically the sender is an nco:Contact, but it is not necessary to enforce that constraint here.
	sender = email.property<nmo::from>());
		// Obtain the nmo:from property of \a email, and constrain \a sender to it. We have now specified that any resources which being bound as \a email must have been sent by some entities that get bound as \a sender, and we did this using using the nmo ontology.
	sender.property<nco::nameGiven>() = LiteralValue(name);
		// Further constrain the nco:nameGiven property of sender to the string \a name.

		// What we have done so far is to add constraints to the two RDFVariables and connect them together in a triple relationship.
		// Now email represents all objects of type nmo::Email that come from senders who have nco::nameGiven set to \a name.

		// Next we build the query and get the subject of each of those emails in the result as well.

	RDFSelect select;
		// Create the selection object
	select.addColumn("EmailId", email);
		// Add a new column with header name "EmailId", and set it to represent the email variable.
		// What will appear in this column are the uri identifiers of the nmo::Email objects.

	RDFVariable subject = email.property<nmo::messageSubject>();
		// Obtain the nmo::messageSubject of email.
	select.addColumn("EmailSubject", subject);
		// Add a new column "EmailSubject", with the subject as contents.

	LiveNodes query_model = ::tracker()->modelQuery(select);
		// Bind the query with the ::tracker() source graph, which yields the results in a LiveNodes object. It is a smart, shared pointer to a LiveNodeModel, which in turn extends QAbstractItemModel and contains the actual result data in a table form. This model now contains all emails sent by entity/entities with the \a name and the subject of those emails.
		// As the model is shared by LiveNodes, we can pass it around cheaply. The model gets destroyed only when last LiveNodes sharing it is destroyed.
	return query_model;
}
	 *	\endcode
	 *  Another example in compact form, which retrieves all contacts from a given region:
	 *  \code
LiveNodes getContactsInRegion(QString region)
{
	RDFSelect select;
	RDFVariable contact;
	contact.property<nco::hasPostalAddress>().property<nco::region>() == LiteralValue(region);
	select.orderBy(contact.property<nco::birthDate>()]);
	select.addColumn("Full name", contact.property<nco::fullname>());
}
	 *  \endcode
	 *
	 *	The constraints consist of subject-predicate-object type of constraints as well as filters that limit values of an RDFVariable.
	 *
	 *	An \ref RDFPattern consists of a set of constraints, and a set of RDFVariable aliases it owns and is used to implement optional and union constraint groups.
	 *
	 *	An RDFSelect object, or selection, is then used to map a set of variables into a table form implemented by a \ref LiveNodeModel with each row representing a variable combination and each column denoting a variable.
	 *
	 *	Finally, \ref RDFGraph is used to combine the selection with a specific RDF graph into a concrete set of rows.
	 *
	 *	\section unbound_filters Filters and expressions
	 *	Filters are a constraint that filter out results using arithmetic and builtin expressions.
	 *	There are two kinds of components, \a assertion expressions and \a arithmetic expressions.
	 *	\ref unbound_filters "Assertion expression"s represent a boolean concept, arithmetic ones cover everything else.
	 *	These expressions are built using specific \ref RDFVariable members, which combine with other variables into expressions with some operation.
	 *	They are then returned as RDFFilter and RDFVariable objects, and can be combined into further expressions.
	 *
	 *	The RDFFilter represents the assertion expression.
	 *	The main and only difference from an arithmetic expression is that if an RDFFilter, or assertion expression, is not used further as an initializer of another variable, it is inserted into the pattern which owns it and takes effect.
	 *	\code
void filter(RDFVariable var)
{
	var.hasPrefix("Jack");
		// hasPrefix is an assertion expression, and the returned assertion isn't used.
		// This assertion takes effect, and var now has to have "Jack" as text prefix.
}
	 *	\endcode
	 *	However, if an assertion expression is captured by assigning it into a variable or used as a parameter, it is not converted to a filter directly.
	 *	It then has to be explicitly used with \ref RDFPattern::use, or asserted again with \ref RDFVariable::isTrue to take effect.
	 *	\code
void filter2(RDFVariable var, bool do_filter)
{
	RDFVariable filter = var.hasPrefix("Jack");
		// hasPrefix doesn't take effect as it is used to initialize filter, which now represents it.
	if(do_filter)
		filter.isTrue();
			// Only here is the filter enforced
}
	 *	\endcode
	 *
	 *	It can be easily seen that constructs that dont make sense can be constructed using these tools.
	 *	Diagnostics aren't currently offered for ill-formed filter expressions,
	 *	Instead look at the resulting SPARQL to see what's wrong.
	 */

	class RDFVariable;

	class RDFVariableLink;
	class RDFFilter;
	class RDFPattern;

	class RDFPropertyData;

	class RDFUpdate;
	class RDFSelect;
	class RDFSubSelect;

	namespace Detail
	{
			template<typename Chain_
					, RDFStrategyFlags is_chained = (Chain_::BaseStrategy & RDFStrategy::ChainedProperty)>
		struct RDFPropertyChain;
	}

	/*!
	 *
	 * Main article at \ref user_manual_unbound_rdfvariable.
	 * Core element of the \ref layer_unbound "unbound services".
	 * RDFVariable objects representing a set of constaints are connected to each other and constrained with various operations.
	 * These connections and constraints are created through member functions, which are marked with "Constraint", "Connection" or "Expression" tags.
	 * An RDFVariable internally remembers all constraints, connections and aggregate expressions made to other RDFVariables.
	 * This is true even if some RDFVariable instance is destroyed.
	 * Thus, implicitly, all constraints of all variables that are connected to the variable, can also affect it (but not necessarily always do).
	 * Variable is \a unknown when no constraints have been added to it.
	 * NOTE: assignment to an RDFVariable object will cause a merge. This is a deprecated usage.
	 * If you need to reset an RDFVariable object, you should use RDFVariable::metaClear, and
	 * if you wish to assign a completely new value without merge, you should use
	 * RDFVariable::metaAssign.
	 *
	 * \sa \ref RDFPattern
	 */
	class Q_DECL_EXPORT RDFVariable
	{
	public:
        //!\name Constructors, static creators, deep copiers
        //@{
		RDFVariable();
		/*!
		 * Connection.
		 * If the node is empty, the variable isn't constrained, and will thus be \a unknown.
		 * If the node is blank, the variable isn't constrained but is explicitly blank.
		 * Otherwise, the variable is constrained to the value of the given node
		 * or to be a member of the given set, and thus makes it \a explicitly definite.
		 * \sa setEqualTo.
		 */
		RDFVariable(LiveNode const &node);

		//! \overload
		RDFVariable(Node const &node);

		//! \overload
		RDFVariable(QUrl const &iri);

		//! \overload
		RDFVariable(LiteralValue const &iri);

		//! \overload
		RDFVariable(LiveNodes const &set);

// TODO: on ABI break, change from QSharedDataPointer<Data> to QSharedDataPointer<QSharedData>
//			template<typename Entity_, typename Policy_, typename MD_>
//		RDFVariable(ValueOfLiveEntity<Entity_, Policy_, MD_> const &entity) : d() { *this = entity.variable(); }

		/*!
		 * The variable is associated with given \a strategy and optionally given \a identifier.
		 * If \a identifier is specified, the variable is explicitly blank. The identifier is meta
		 * information, and is used for example as the result set table header name.
		 */
		explicit RDFVariable(RDFStrategyFlags const &strategy, QString const &identifier);

		//! \overload
		//! \sa isExplicit
		explicit RDFVariable(QString const &identifier);
		//! \overload
		//! \sa isExplicit
		explicit RDFVariable(const char *identifier);

		/*!
		 * Connection.
		 * The variable is made an alias of the \a copy.
		 * \sa setEqualTo.
		 */
		RDFVariable(RDFVariable const &copy);
		~RDFVariable();

		//! Swap the contents with given \a other
		void swap(RDFVariable &other);

		static inline RDFVariable fromInstance(RDFVariable const &var) { return var; }
		static RDFVariable fromInstance(LiveNode const &node);
		static inline RDFVariable fromInstance(Node const &node) { return node; }
		static inline RDFVariable fromInstance(QUrl const &iri) { return iri; }
		static RDFVariable fromInstance(LiveNodes const &nodes);
		static inline RDFVariable fromInstance(LiteralValue const &literal) { return literal; }
		static inline RDFVariable fromInstance(QString const &iri) { return LiteralValue(iri); }

		//! \return a variable constrained to given \a Resource_
			template<typename Resource_>
		static inline RDFVariable fromInstance(RDFStrategyFlags strategy = RDFStrategy::BoundDerivedProperty);


		static RDFVariable createEmpty();
		/*!
		 * Construct a new variable which is constrained to be of the given local \a Type_.
		 */
			template<typename Type_>
		static inline RDFVariable fromType(QString const &identifier = QString(), RDFStrategyFlags strategy = RDFStrategy::BoundDerivedProperty)
		{ 	return RDFVariable(identifier).isOfType<Type_>(strategy); }

		//! \overload
		static inline RDFVariable fromType(LiveNode const &type, QString const &identifier = QString(), RDFStrategyFlags strategy = RDFStrategy::BoundDerivedProperty)
		{ 	return RDFVariable(identifier).isOfType(type, strategy); }

		//! \overload
		static inline RDFVariable fromType(RDFVariable const &type, QString const &identifier = QString(), RDFStrategyFlags strategy = RDFStrategy::BoundDerivedProperty)
		{ 	return RDFVariable(identifier).isOfType(type, strategy); }


#if (QTTRACKER_SUPPORT_VER <= 400)
		//! \overload
		//! \deprecated Support version 1~4.0.x. Nonintuitive function. Use RDFVariable(node).isOfType<Type>()
			template<typename Type_>
		static inline SOPRANO_DEPRECATED RDFVariable fromType(LiveNode const &node)
		{
			// XXXLOG
			//xwarning() << "fromType<Type>(node): DEPRECATED 1~4.0.x. Nonintuitive function. Use RDFVariable(node).isOfType<Type>();";
			return RDFVariable(node).isOfType<Type_>();
		}
#endif

		//! \return a variable representing the given \a set of variables.
		static inline RDFVariable fromContainer(RDFVariableList const &set, QString const &identifier = QString());

		//! \return a variable representing the given \a container of items, optionally identified by given \a identifier.
			template<typename Cont_>
		static inline RDFVariable fromContainer(Cont_ const &container, QString const &identifier = QString());

			template<typename Iter_>
		static inline RDFVariable fromRange(Iter_ const &begin, Iter_ const &end, QString const &identifier = QString());

		//! \return a variable representing the union of given \a set of variables
		static inline RDFVariable fromUnion(RDFVariableList const &set, QString const &identifier = QString());

		/*!
		 * A copier structure for performing full, deep copies of RDFVariable
		 * graphs and graph sets. It can be explicitly constructed and passed
		 * to multiple \ref deepCopy functions, in which case the actual final
		 * copying is performed only when DeepCopier is destroyed. All
		 * RDFVariable objects whose original copies shared a graph will end
		 * up sharing the resulting, copied graph. RDFVariable objects
		 * returned by the \ref deepCopy functions will be valid the moment
		 * they are returned.
		 */
		class DeepCopier
		{
		public:
			DeepCopier();
			DeepCopier(DeepCopier const &);
			~DeepCopier();
			RDFVariable copy(RDFVariable const &copy) const;
			RDFVariableList copy(RDFVariableList const &variables) const;
			RDFPattern copy(RDFPattern const &copy) const;
			RDFSubSelect copy(RDFSubSelect const &copy) const;

				template<typename Seq_>
				Seq_ copySequence(Seq_ const &item_seq) const
			{
				Seq_ ret;
				for(typename Seq_::const_iterator ci = item_seq.begin(), ciend = item_seq.end(); ci != ciend; ++ci)
					ret.push_back(ci->deepCopy(*this));
				return ret;
			}
		protected:
			struct Data;
			Data *d;
		};

		/*!
		 * Performs a deep copy on the variable and the graph of all associations.
		 * The copied graph and the current are initially separate, thus
		 * constraints and connections to either one do not initially affect
		 * each other, however they can be later connected as normal.
		 * \return the copied variable
		 */
		RDFVariable deepCopy(DeepCopier const &copier) const;
		RDFVariable deepCopy() const { return deepCopy(DeepCopier()); }

		/*!
		 * Performs a deep copy on the given \a variables set and the graphs of
		 * all their associations. All variables belonging to the same graph will
		 * be copied together, and the resulting variables will thus also belong
		 * to same connected graph.
		 * \param copier a copying context storing the mapping information from
		 * source to target graphs, allowing many calls to deepCopy while not
		 * generating new graphs.
		 * \return the copied variables
		 */
		static RDFVariableList deepCopy(RDFVariableList const &variables, DeepCopier const &copier);
		static RDFVariableList deepCopy(RDFVariableList const &variables) { return deepCopy(variables, DeepCopier()); }
		//@}



		//! \name Variable meta information manipulators and accessors
		//@{
		//! \return true if variable is empty and has no modifications; false otherwise
		bool metaIsEmpty() const;

		//! \deprecated Use metaIsUnconstrained instead
		SOPRANO_DEPRECATED bool metaIsUnknown() const;

		//! \return true if the variable is \a unknown.
		//! Variable is \a unconstrained if no constaints have been added to it.
		//! Constraints include variable expression statements and triples.
		bool metaIsUnconstrained() const;

		//! \return true if variable is unconstrained blank; false otherwise.
		//! If true, implies metaIsBlank.
		bool metaIsUnconstrainedBlank() const;

		//! \alias for inverse of metaIsUnknown
		//! \deprecated Use metaIsEmpty, metaHasConstraints
		SOPRANO_DEPRECATED bool metaHasConstraints() const { return metaIsConstrainedBlank(); }

		//! \return true if variable is constrained blank; false otherwise.
		//! If true, implies metaIsBlank.
		bool metaIsConstrainedBlank() const;

		/*!
		 * \return true if the variable is \a explicit.
		 * Explicit variables will not be aliased with other explicit variables.
		 * This is useful in ensuring that a variable isn't accidentally bound
		 * where it shouldn't be.
		 * Variable is intrinsically \a explicit if it is explicitly defined as single
		 * node value or if it is given an explicit blank identifier.
		 */
		bool metaIsExplicit() const;

		void metaSetExplicit(bool explicit_ = true);

		/*!
		 * \return true if the variable is \a explicitly definite.
		 * Calling metaValue will return the value this variable is bound to.
		 */
		bool metaIsDefinite() const;

		//! \deprecated Use metaIsDefinite instead.
		SOPRANO_DEPRECATED bool metaIsBound() const;

		/*!
		 * \return true if the variable is \a explicitly blank.
		 * Calling metaValue will return the blank node this variable is bound to.
		 */
		bool metaIsBlank() const;

		//! \return true if this is an expression variable; false otherwise
		bool metaIsExpression() const;

		/*!
		 * Resets the variable without affecting the underlying variable graph or constraints.
		 * Analoguous to conventional "a = T();" idiom.
		 */
		void metaClear();

		/*!
		 * Assigns another variable to this variable, without affecting
		 * underlying variable graph or constraints.
		 * Analoguous to conventional "a = b;" idiom.
		 */
		void metaAssign(RDFVariable const &rhs);

		/*!
		 * \return the value of this variable, which can be either a definite url or literal,
		 * blank node with an identifier or an empty node.
		 */
		LiveNode metaValue() const;

		/*!
		 * \deprecated Use metaValue instead.
		 * \return the explicit value of this variable.
		 * If variable is not explicit, the returned LiveNode will be empty or blank.
		 */
		SOPRANO_DEPRECATED LiveNode metaExplicitValue() const;

		//! \return current meta identifier if set; empty string otherwise.
		QString metaIdentifier() const;

		//! Set variable identifier to given \a identifier. Makes variable explicitly blank.
		void metaSetIdentifier(QString const &identifier);


		//! \return list of the given \a attribute_name, or an empty list if attribute is not set
		QList<QVariant> metaAttribute(QString const &attribute_name) const;

		//! Set the given \a attribute_name to given \a value
		void metaInsertAttribute(QString const &attribute_name, QVariant const &value);

		//! Set the given \a attribute_name to given \a value
		void metaRemoveAttribute(QString const &attribute_name);

		//! \return the attribute map of the variable
		QVariantMap metaAttributeMap() const;

		//! Set the given \a attribute_map of the variable
		void metaSetAttributeMap(QVariantMap const &attribute_map);

		/*!
		 * Adds the given \a property_data to the derived properties of this
		 * variable.
		 * If this variable is used directly to represent resources in a result set,
		 * the cached property rules give a hint to the implementation to precache properties
		 * matching all cached property rules.
		 * Warning: may cause circular dependencies and memory leaks, if the
		 * cached property rules are in the same connected graph as the parent
		 * RDFVariable itself.
		 * Takes semantic ownership of the property_data. Use property_data.deepCopy
		 * while passing arguments to avoid altering the original if so desired.
		 * \ŗeturn property_data.variable()
		 */
		RDFVariable addDerivedProperty(RDFProperty &property_data) const;
		RDFVariable addDerivedProperty(RDFProperty const &property_data) const;

		/*!
		 * \return the list of derived property rules.
		 * The entries in the list are actually RDFVariableLink's to the internal
		 * rules, so they can be manipulated without affecting existing contents.
		 */
		QVector<RDFProperty> derivedProperties() const;

		//! Sets all derived properties to given \a derived_properties
		void setDerivedProperties(QVector<RDFProperty> const &derived_properties) const;

#if (QTTRACKER_SUPPORT_VER <= 603)
		//! \deprecated Use \ref addDerivedProperty(RDFProperty &property_data) const;
		SOPRANO_DEPRECATED RDFVariable metaAddCachedProperty(RDFProperty &property_data) const;

		//! \deprecated Use \ref addDerivedProperty(RDFProperty const &property_data) const;
		SOPRANO_DEPRECATED RDFVariable metaAddCachedProperty(RDFProperty const &property_data) const;

		//! \deprecated Use \ref derivedProperties() const;
		SOPRANO_DEPRECATED QVector<RDFProperty> metaCachedProperties() const;
#endif


		//! Sets associated strategy flags to given \a strategy
		void metaSetStrategy(RDFStrategyFlags strategy);
		//! Enables given \a strategy flags from associated strategy
		void metaEnableStrategyFlags(RDFStrategyFlags strategy);
		//! Disables given \a strategy flags from associated strategy
		void metaDisableStrategyFlags(RDFStrategyFlags strategy);

		//! Sets associated strategy flags
		RDFStrategyFlags metaStrategy() const;


		/*!
		 * \overload
		 * Adds the given object \a Property_ to the cached property rules.
		 */
		RDFVariable addDerivedObject(RDFVariable const &predicate, RDFVariable const &object_info = RDFVariable(), RDFStrategyFlags strategy = RDFStrategy::DefaultStrategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const;

		/*!
		 * \overload
		 * Adds the given object \a Property_ to the cached property rules.
		 */
			template<typename Property_>
		RDFVariable addDerivedObject(RDFVariable const &object_info = RDFVariable(), RDFStrategyFlags strategy = RDFStrategy::DefaultStrategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const;

		/*!
		 * \overload
		 * Adds the given object \a Property_ to the cached property rules.
		 */
			template<typename Property_>
		RDFVariable addDerivedObject(RDFStrategyFlags strategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{ return addDerivedObject<Property_>(RDFVariable(), strategy, parent); }

		/*!
		 * \overload
		 * Adds the given object \a property_chain to the cached property rules.
		 */
			template<typename Chain_>
		RDFVariable addDerivedObject(Detail::RDFPropertyChain<Chain_> &property_chain, RDFVariable const &object_info, RDFStrategyFlags strategy = RDFStrategy::DefaultStrategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const;

		/*!
		 * \overload
		 * Adds the given object \a Property_ to the cached property rules.
		 */
		RDFVariable addDerivedSubject(RDFVariable const &predicate, RDFVariable const &subject_info = RDFVariable(), RDFStrategyFlags strategy = RDFStrategy::DefaultStrategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const;

		/*!
		 * \overload
		 * Adds the given subject \a Property_ to the cached property rules.
		 */
			template<typename Property_>
		RDFVariable addDerivedSubject(RDFVariable const &subject_info = RDFVariable(), RDFStrategyFlags strategy = RDFStrategy::DefaultStrategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const;

		/*!
		 * \overload
		 * Adds the given subject \a Property_ to the cached property rules.
		 */
			template<typename Property_>
		RDFVariable addDerivedSubject(RDFStrategyFlags strategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{ return addDerivedSubject<Property_>(RDFVariable(), strategy, parent); }

		/*!
		 * \overload
		 * Adds the given subject \a property_chain to the cached property rules.
		 */
			template<typename Chain_>
		RDFVariable addDerivedSubject(Detail::RDFPropertyChain<Chain_> &property_chain, RDFVariable const &subject_info, RDFStrategyFlags strategy = RDFStrategy::DefaultStrategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const;

		/*!
		 * \overload
		 * Adds the given object \a Property_ to the cached property rules.
		 */
		RDFVariable addUpdateObject(RDFVariable const &predicate, RDFVariable const &object_info = RDFVariable(), RDFStrategyFlags strategy = RDFStrategy::DefaultStrategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const;

		/*!
		 * \overload
		 * Adds the given object \a Property_ to the cached property rules.
		 */
			template<typename Property_>
		RDFVariable addUpdateObject(RDFVariable const &object_info = RDFVariable(), RDFStrategyFlags strategy = RDFStrategy::DefaultStrategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const;

		/*!
		 * \overload
		 * Adds the given object \a Property_ to the cached property rules.
		 */
			template<typename Property_>
		RDFVariable addUpdateObject(RDFStrategyFlags strategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{ return addUpdateObject<Property_>(RDFVariable(), strategy, parent); }

		/*!
		 * \overload
		 * Adds the given object \a Property_ to the cached property rules.
		 */
		RDFVariable addUpdateSubject(RDFVariable const &predicate, RDFVariable const &subject_info = RDFVariable(), RDFStrategyFlags strategy = RDFStrategy::DefaultStrategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const;

		/*!
		 * \overload
		 * Adds the given subject \a Property_ to the cached property rules.
		 */
			template<typename Property_>
		RDFVariable addUpdateSubject(RDFVariable const &subject_info = RDFVariable(), RDFStrategyFlags strategy = RDFStrategy::DefaultStrategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const;

		/*!
		 * \overload
		 * Adds the given subject \a Property_ to the cached property rules.
		 */
			template<typename Property_>
		RDFVariable addUpdateSubject(RDFStrategyFlags strategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{ return addUpdateSubject<Property_>(RDFVariable(), strategy, parent); }


#if (QTTRACKER_SUPPORT_VER <= 603)
		//! \deprecated Use \ref addDerivedObject;
			template<typename Property_>
		SOPRANO_DEPRECATED RDFVariable metaAddCachedObject(RDFVariable const &object_info = RDFVariable(), RDFStrategyFlags strategy = RDFStrategy::DefaultStrategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const { return addDerivedObject<Property_>(object_info, strategy, parent); }

		//! \deprecated Use \ref addDerivedObject;
			template<typename Property_>
		SOPRANO_DEPRECATED RDFVariable metaAddCachedObject(RDFStrategyFlags strategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const { return addDerivedObject<Property_>(RDFVariable(), strategy, parent); }

		//! \deprecated Use \ref addDerivedSubject;
			template<typename Property_>
		SOPRANO_DEPRECATED RDFVariable metaAddCachedSubject(RDFVariable const &subject_info = RDFVariable(), RDFStrategyFlags strategy = RDFStrategy::DefaultStrategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const { return addDerivedSubject<Property_>(subject_info, strategy, parent); }

		//! \deprecated Use \ref addDerivedSubject;
			template<typename Property_>
		SOPRANO_DEPRECATED RDFVariable metaAddCachedSubject(RDFStrategyFlags strategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const { return addDerivedObject<Property_>(RDFVariable(), strategy, parent); }

		//! \deprecated Use \ref addDerivedObjectAlias;
			template<typename PropertyChain_>
		SOPRANO_DEPRECATED RDFVariable metaAddAliasObject(PropertyChain_ const &property_chain, RDFStrategyFlags strategy = RDFStrategy::DefaultStrategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const { return addDerivedObjectOfChain(property_chain, strategy, parent); }

		//! \deprecated Use \ref addDerivedSubjectAlias;
			template<typename PropertyChain_>
		SOPRANO_DEPRECATED RDFVariable metaAddAliasSubject(PropertyChain_ const &property_chain, RDFStrategyFlags strategy = RDFStrategy::DefaultStrategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const { return addDerivedSubjectOfChain(property_chain, strategy, parent); }
#endif

		/*!
		 * \return the pattern which owns this variable.
		 * \sa RDFPattern
		 */
		RDFPattern pattern() const;

		/*!
		 * Sets the active pattern to given \a pattern.
		 * Does not alter any of the old constraints or connections, only affects
		 * the pattern where future constraints will be placed.
		 */
		void setPattern(RDFPattern const &pattern);

#if (QTTRACKER_SUPPORT_VER <= 400)
		/*!
		 * \return the local type this variable is constrained to,
		 * or None if there is no local constraint.
		 * If the type of this variable is constrained to an rdf type,
		 * this function will return CppType::of<LiveNode>()
		 * \deprecated Support version 1~4.0.x. Var prefix addition. Use \ref varCppType()
		 */
		SOPRANO_DEPRECATED CppType cppType() const { return varCppType(); }

		/*!
		 * \return the pattern which owns this variable.
		 * \sa RDFPattern
		 * \deprecated Support version 1~4.0.x. Var prefix removal. Use \ref pattern()
		 */
		SOPRANO_DEPRECATED RDFPattern varPattern() const;


		/*!
		 * Sets the active pattern to given \a pattern.
		 * Does not alter any of the old constraints or connections, only affects
		 * the pattern where future constraints will be placed.
		 * \deprecated Support version 1~4.0.x. Var prefix removal.
		 * Use \ref setPattern(RDFPattern const &pattern)
		 */
		SOPRANO_DEPRECATED void varSetPattern(RDFPattern const &pattern);
#endif

		/*!
		 * \return the local type this variable is constrained to,
		 * or None if there is no local constraint.
		 * If the type of this variable is constrained to an RDF type,
		 * this function will return CppType::of<LiveNode>()
		 */
		CppType varCppType() const;

		/*!
		 * \return true if this variable is represents a resource
		 */
		bool metaIsResource() const;

		//@}

		//! \name Constraint and connection functions

		/*!
		 * Constraint, connection.
		 * The variable is merged with given \a alias. The merged variables
		 * will behave as one, they will share all connections and constraints,
		 * except for their old parent pattern affiliations, which they retain
		 * separately. Also, this function is an actual constraint only if both
		 * variables are not \a unknown. If neither or both variables are
		 * \a unknown, the state of either will not be changed.
		 * Otherwise, the \a unknown status of the other alias is removed.
		 */
		void merge(RDFVariable const &alias) const { return setEqualTo(alias); }

		//! \overload
		void setEqualTo(RDFVariable const &alias) const;

		//! \overload
		void setAlias(RDFVariable const &alias) const { return merge(alias); }

		/*!
		 * Constraint, connection.
		 * Operator shortcut for \ref setEqualTo
		 */
		inline RDFVariable &operator=(RDFVariable const &alias) { merge(alias); return *this; }



		/*!
		 * Constraint, connection.
		 * \return a variable that is constrained to be the object of this variable and given \a predicate. \n
		 * As a direct side-effect, constrains this variable to be the subject of given \a predicate.
		 */
		RDFVariable property(RDFVariable const &predicate) const;

		/*!
		 * Constraint, connection.
		 * Constrains this variable to be the subject or object of the given \a property_data,
		 * depending on whether the property_data describes a object/predicate strategy or subject/predicate strategy.
		 * \return the \a property from \a property_data. \n
		 * Does alter \a property_data constraints. If you want the argument to remain unchanged, use \ref RDFProperty::deepCopy.
		 * If the strategy in \a object_params has CacheProperty enabled, \a property_data
		 * will be added to the cached property rules, analoguous to calling \ref metaAddCachedProperty(\a property_data).
		 * \sa metaAddCachedProperty
		 */
		RDFVariable property(RDFProperty const &property_data) const;
#if (QTTRACKER_SUPPORT_VER <= 603)
		//! \deprecated. Support version 1~6.3.x. Use bindSubject instead.
		SOPRANO_DEPRECATED RDFVariable property(RDFProperty &property_data) const;
#endif
		RDFVariable bindProperty(RDFProperty &property_data) const;

		/*!
		 * Constraint, connection.
		 * Operator shortcut for \ref property
		 */
		inline RDFVariable operator[](RDFVariable const &predicate) const
		{	return property(predicate); }

		/*!
		 * \overload
		 * \return a variable that is constrained to be the object of this variable and given \a Property_.
		 */
			template<typename Property_>
		RDFVariable property( RDFVariable const &property_data = RDFVariable()
				            , RDFStrategyFlags strategy = RDFStrategy::Disabled
				            , QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const;

		/*!
		 * \overload
		 * \return a variable that is constrained to be the object of this variable and given \a Property_.
		 */
			template<typename Property_>
		RDFVariable property(RDFStrategyFlags strategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{ return property<Property_>(RDFVariable(), strategy, parent); }

		/*!
		 * \overload
		 * Constrain this variable to have given \a Property_ of \a ObjectResource_
		 * \return variable representing \a ObjectResource_.
		 */
			template<typename Property_, typename ObjectResource_>
		RDFVariable property(RDFStrategyFlags strategy = RDFStrategy::Disabled, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{ return property<Property_>(ObjectResource_::iri(), strategy, parent); }

		//! \overload
		//! \sa property
		RDFVariable object(RDFVariable const &predicate) const { return property(predicate); }

		//! \overload
		//! \sa property
		RDFVariable object(RDFProperty const &object_data) const;
#if (QTTRACKER_SUPPORT_VER <= 603)
		//! \deprecated. Support version 1~6.3.x. Use bindSubject instead.
		SOPRANO_DEPRECATED RDFVariable object(RDFProperty &object_data) const;
#endif
		RDFVariable bindObject(RDFProperty &object_data) const;

		//! \overload
		//! \sa property
			template<typename Property_>
		RDFVariable object( RDFVariable const &object_info = RDFVariable()
		                  , RDFStrategyFlags strategy = RDFStrategy::Disabled
		                  , QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const;

		//! \overload
		//! \sa property
			template<typename Property_>
		RDFVariable object(RDFStrategyFlags strategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{ return object<Property_>(RDFVariable(), strategy, parent); }

		//! \overload
		//! \sa property
			template<typename Property_, typename Object_>
		RDFVariable object(RDFStrategyFlags strategy = RDFStrategy::Disabled, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{ return object<Property_>(Object_::iri(), strategy, parent); }

		//! \overload
		//! Also registers the object as a derived property
			template<typename Property_>
		RDFVariable derivedObject(RDFVariable const &object_info = RDFVariable(), RDFStrategyFlags strategy = RDFStrategy::Disabled, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{ return object<Property_>(object_info, strategy | RDFStrategy::BoundDerivedProperty, parent); }

		//! \overload
		//! Also registers the object as a derived property
			template<typename Property_>
		RDFVariable derivedObject(RDFStrategyFlags strategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{ return object<Property_>(RDFVariable(), strategy | RDFStrategy::BoundDerivedProperty, parent); }

#if (QTTRACKER_SUPPORT_VER <= 603)
		//! \deprecated. Support version 1~6.3.x. Use derivedObject Instead.
			template<typename Property_>
		RDFVariable cachedObject(RDFVariable const &object_info = RDFVariable(), RDFStrategyFlags strategy = RDFStrategy::Disabled, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{ return object<Property_>(object_info, strategy | RDFStrategy::BoundDerivedProperty, parent); }

		//! \deprecated. Support version 1~6.3.x. Use derivedObject Instead.
			template<typename Property_>
		RDFVariable cachedObject(RDFStrategyFlags strategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{ return object<Property_>(RDFVariable(), strategy | RDFStrategy::BoundDerivedProperty, parent); }
#endif

		/*!
		 * Constraint.
		 * \return a variable that is constrained to be the subject of this variable and given \a Property_. \n
		 * As a direct side-effect, constrains this variable to be the object of given \a Property_ and the \a predicate.
		 */
		RDFVariable subject(RDFVariable const &predicate) const
		{ RDFVariable subject; subject.object(predicate) = *this; return subject; }

		/*!
		 * Constraint, connection.
		 * Constrains this variable to be the \a object of the \a predicate and \a subject in the given \a subject_data.
		 * \return the \a subject from \a subject_data. \n
		 * Does alter \a subject_data constraints. If you want the argument to remain unchanged, use \ref RDFProperty::deepCopy.
		 * If the strategy in \a object_params has CacheProperty enabled, \a subject_data will be added to the cached subject rules.
		 * \sa property, metaAddCachedProperty
		 */
		RDFVariable subject(RDFProperty const &subject_data) const;
#if (QTTRACKER_SUPPORT_VER <= 603)
		//! \deprecated. Support version 1~6.3.x. Use bindSubject instead.
		SOPRANO_DEPRECATED RDFVariable subject(RDFProperty &subject_data) const;
#endif
		RDFVariable bindSubject(RDFProperty &subject_data) const;

		//! \overload
			template<typename Property_>
		RDFVariable subject(RDFVariable const &subject_info = RDFVariable(), RDFStrategyFlags strategy = RDFStrategy::Disabled, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const;

		//! \overload
			template<typename Property_>
		RDFVariable subject(RDFStrategyFlags strategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{ return subject<Property_>(RDFVariable(), strategy, parent); }

		//! \overload
			template<typename Property_, typename SubjectResource_>
		RDFVariable subject(RDFStrategyFlags strategy = RDFStrategy::Disabled, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{ return subject<Property_>(SubjectResource_::iri(), strategy, parent); }

		//! \overload
		//! Also registers the subject as a derived property
			template<typename Property_>
		RDFVariable derivedSubject(RDFVariable const &subject_info = RDFVariable(), RDFStrategyFlags strategy = RDFStrategy::Disabled, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{ return subject<Property_>(subject_info, strategy | RDFStrategy::BoundDerivedProperty, parent); }

		//! \overload
		//! Also registers the subject as a derived property
			template<typename Property_>
		RDFVariable derivedSubject(RDFStrategyFlags strategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{ return subject<Property_>(RDFVariable(), strategy | RDFStrategy::BoundDerivedProperty, parent); }

#if (QTTRACKER_SUPPORT_VER <= 603)
		//! \deprecated. Support version 1~6.3.x. Use derivedSubject Instead.
			template<typename Property_>
		RDFVariable cachedSubject(RDFVariable const &subject_info = RDFVariable(), RDFStrategyFlags strategy = RDFStrategy::Disabled, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{ return subject<Property_>(subject_info, strategy | RDFStrategy::BoundDerivedProperty, parent); }

		//! \deprecated. Support version 1~6.3.x. Use derivedSubject Instead.
			template<typename Property_>
		RDFVariable cachedSubject(RDFStrategyFlags strategy, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()) const
		{ return subject<Property_>(RDFVariable(), strategy | RDFStrategy::BoundDerivedProperty, parent); }
#endif

		/*!
		 * Constraint.
		 * \return a variable constrained to the type of this variable.
		 */
		RDFVariable type() const;
		RDFVariable type(RDFStrategyFlags strategy) const;
		RDFVariable type(RDFVariable const &type, RDFStrategyFlags strategy) const;

		/*!
		 * Constraint.
		 * Constrains the type of this variable to be a best match of the given local \a type.
		 * LiveNodeModel will use this information internally.
		 * Will not make the variable non-unknown.
		 * \param strict If true, variable will be strictly constrained to the type; otherwise
		 * will match any values with conversions to this type.
		 * \return self
		 */
		RDFVariable isOfType(CppType type, bool strict = false) const;
		inline RDFVariable isOfType(CppType type, bool strict, RDFStrategyFlags strategy) const { Q_UNUSED(strategy); return isOfType(type, strict); }

		/*!
		 * Constraint.
		 * Will make the variable non-unknown.
		 * Constrain this variable to be of the given rdf \a type.
		 */
		inline RDFVariable isOfType(QUrl type, RDFStrategyFlags strategy = RDFStrategy::BoundDerivedProperty) const { this->type(type, strategy); return *this; }

		// this is a helper function, rdf type will be always strict.
		inline RDFVariable isOfType(QUrl type, bool /*strict_dummy*/, RDFStrategyFlags strategy = RDFStrategy::BoundDerivedProperty) const { this->type(type, strategy); return *this; }

		//! \overload
		inline RDFVariable isOfType(LiveNode const &type, RDFStrategyFlags strategy = RDFStrategy::BoundDerivedProperty) const { this->type(type, strategy); return *this; }

		//! \overload
		inline RDFVariable isOfType(RDFVariable const &type, RDFStrategyFlags strategy = RDFStrategy::BoundDerivedProperty) const { this->type(type, strategy); return *this; }

		/*!
		 * Constraint.
		 * Constrain this variable to be of the given local \a Type_.
		 * LiveNodeModel will use this information internally.
		 * \param strict If True, variable will be strictly constrained to the type;
		 * otherwise will match any values with conversions to this type.
		 */
			template<typename Type_>
		inline RDFVariable isOfType(bool strict = false, RDFStrategyFlags strategy = RDFStrategy::BoundDerivedProperty) const;

		/*!
		 * \return a new unconstrained variable belonging to the pattern of this variable.
		 */
		RDFVariable variable(QString explicit_name = QString()) const;

		/*!
		 * \return an alias of the given \a variable belonging to the pattern of this variable.
		 */
		RDFVariable variable(RDFVariable const &variable) const;

		/*!
		 * Connection.
		 * \return an alias of this variable belonging to a new pattern which
		 * is in a child-relationship with the pattern of this variable. \n
		 * Used with union_
		 * \sa RDFPattern
		 */
		RDFVariable child() const;
		/*!
		 * Connection.
		 * Alias the given \a variable with this variable, and place its the constraints into a child pattern.
		 * \return this variable belonging to the child pattern. \n
		 * Used with union_
		 * \sa RDFPattern
		 */
		RDFVariable child(RDFVariable const &variable) const;
		/*!
		 * Connection.
		 * \return an union-relationship alias of this variable.
		 * \sa RDFPattern
		 */
		RDFVariable union_() const;
		/*!
		 * Connection.
		 * Alias the given \a variable with this variable, and place its the
		 * constraints into a union_ pattern.
		 * \return this variable belonging to the child pattern.
		 * \sa RDFPattern
		 */
		RDFVariable union_(RDFVariable const &variable) const;

		/*!
		 * Connection.
		 * \param union_list a list of variables which are merged in union
		 * relationship.
		 * \sa RDFPattern
		 */
		void unionMerge(RDFVariableList const &union_list) const;

		/*!
		 * Connection.
		 * \return a set of child variable aliases, each of which is a
		 * union relationship with each other.
		 * \sa RDFPattern
		 */
		RDFVariableList unionChildren(unsigned count) const;

#if (QTTRACKER_SUPPORT_VER <= 603)
		//! \overload
		//! \deprecated Support version 1~6.3.x. Nonintuitive naming. Use unionMerge instead.
		SOPRANO_DEPRECATED void mergeUnion(RDFVariableList const &union_list) const;
		//! \overload
		//! \deprecated Support version 1~6.3.x. Nonintuitive naming. Use unionMerge instead.
		SOPRANO_DEPRECATED void unionChildren(RDFVariableList const &children) const;
		//! \overload
		//! \deprecated Support version 1~6.3.x. Nonintuitive naming. Use unionMerge instead.
		SOPRANO_DEPRECATED void alternatives(RDFVariableList const &alternatives) const { unionMerge(alternatives); }
		//! \overload
		//! \deprecated Support version 1~6.3.x. Nonintuitive naming. Use unionChildren instead.
		SOPRANO_DEPRECATED RDFVariableList alternatives(unsigned count) const { return unionChildren(count); }
#endif
		/*!
		 * Connection.
		 * \return an alias of this variable belonging to a new pattern which is
		 * in a optional-relationship with the pattern of this variable.
		 * \sa RDFPattern
		 */
		RDFVariable optional() const;
		/*!
		 * Connection.
		 * Alias the given \a variable with this variable, and place its
		 * constraints into a optional pattern.
		 * \return this variable belonging to the child pattern.
		 * \sa RDFPattern
		 */
		RDFVariable optional(RDFVariable const &variable) const;

		/*!
		 * \return an alias of this variable in the parent pattern of the
		 * pattern of this variable.
		 */
		RDFVariable inParent() const;

		/*!
		 * \return an alias of this variable in the given \a index'th parent
		 * pattern of the pattern of this variable. If no such pattern
		 * exists or if the index is negative, the topmost pattern is used.
		 */
		enum { TopmostParent = -1 };
		RDFVariable inParent(int index) const;

		/*!
		 * \return an alias of this variable, which belongs to a new pattern belonging to
		 * given \a graph
		 */
		RDFVariable inGraph(RDFVariable const &graph) const;

		/*!
		 * \return an alias of this variable, which belongs to a new \a EXISTS pattern
		 * \sa RDFPattern::exists
		 */
		RDFVariable inExists() const;

		/*!
		 * \return an alias of this variable, which belongs to a new \a NOT EXISTS pattern
		 * \sa RDFPattern::notExists
		 */
		RDFVariable inNotExists() const;

		/*!
		 * \return a variable which is alias of this variable and which has
		 * the given \a pattern as the parent pattern.
		 */
		RDFVariable aliasIn(RDFPattern const &pattern) const;

		/*!
		 * \ref unbound_filters "Assertion expression".
		 * \return assertion expression that this variable is true.
		 */
		RDFFilter isTrue() const;

		/*!
		 * \ref unbound_filters "Assertion expression".
		 * \return assertion expression this variable has the given text \a prefix.
		 */
		RDFFilter hasPrefix(QString const &prefix) const;
		/*!
		 * \ref unbound_filters "Assertion expression".
		 * \return assertion expression this variable has the given text \a suffix.
		 */
		RDFFilter hasSuffix(QString const &suffix) const;
		/*!
		 * \ref unbound_filters "Assertion expression".
		 * \return assertion expression that this variable contains the given text \a infix.
		 */
		RDFFilter contains(QString const &infix) const;
		/*!
		 * \ref unbound_filters "Assertion expression".
		 * \return assertion expression that this variable matches the given regexp \a pattern.
		 */
		RDFFilter matchesRegexp(QString const &pattern) const;
		/*!
		 * \ref unbound_filters "Assertion expression", connection.
		 * \return assertion expression of this being a member of the given \a set of items.
		 */
		RDFFilter isMemberOf(RDFVariableList const &set) const;
		/*!
		 * \overload
		 */
			template<typename Cont_>
		RDFFilter isMemberOf(Cont_ const &container) const;
		/*!
		 * \overload
		 */
			template<typename Iter_>
		RDFFilter isInRange(Iter_ begin, Iter_ const &end) const;

		/*!
		 * \ref unbound_filters "Assertion expression".
		 * \return assertion expression that this variable is not true.
		 */
		RDFFilter not_() const;
		/*!
		 * \ref unbound_filters "Assertion expression", connection.
		 * \return assertion expression of logical \a and between this and given \a rhs.
		 */
		RDFFilter and_(RDFVariable const &rhs) const;
		/*!
		 * \ref unbound_filters "Assertion expression", connection.
		 * \return assertion expression of logical \a or between this and given \a rhs.
		 */
		RDFFilter or_(RDFVariable const &rhs) const;

		/*!
		 * \ref unbound_filters "Assertion expression", connection.
		 * \return assertion expression of equality between this and given \a rhs.
		 */
		RDFFilter equal(RDFVariable const &rhs) const;
		/*!
		 * \ref unbound_filters "Assertion expression", connection.
		 * \return assertion expression of inequality between this and given \a rhs.
		 */
		RDFFilter notEqual(RDFVariable const &rhs) const;
		/*!
		 * \ref unbound_filters "Assertion expression", connection.
		 * \return assertion expression of this being less than given \a rhs.
		 */
		RDFFilter less(RDFVariable const &rhs) const;
		/*!
		 * \ref unbound_filters "Assertion expression", connection.
		 * \return assertion expression of this being greater than given \a rhs.
		 */
		RDFFilter greater(RDFVariable const &rhs) const;
		/*!
		 * \ref unbound_filters "Assertion expression", connection.
		 * \return assertion expression of this being less or equal to given \a rhs.
		 */
		RDFFilter lessOrEqual(RDFVariable const &rhs) const;
		/*!
		 * \ref unbound_filters "Assertion expression", connection.
		 * \return assertion expression of this being greater or equal to given \a rhs.
		 */
		RDFFilter greaterOrEqual(RDFVariable const &rhs) const;
		/*!
		 * \ref unbound_filters "Arithmetic expression".
		 * \return inverse expression of this variable.
		 */
		RDFVariable inv() const;
		/*!
		 * \ref unbound_filters "Arithmetic expression", connection.
		 * \return sum expression of this variable and given \a rhs.
		 */
		RDFVariable add(RDFVariable const &rhs) const;
		/*!
		 * \ref unbound_filters "Arithmetic expression", connection.
		 * \return difference expression of given \a rhs from this variable.
		 */
		RDFVariable sub(RDFVariable const &rhs) const;
		/*!
		 * \ref unbound_filters "Arithmetic expression", connection.
		 * \return product expression of this and given \a rhs.
		 */
		RDFVariable mul(RDFVariable const &rhs) const;
		/*!
		 * \ref unbound_filters "Arithmetic expression", connection.
		 * \return quotient expression of given \a rhs from this variable.
		 */
		RDFVariable div(RDFVariable const &rhs) const;

		/*!
		 * \ref unbound_filters "Assertion expression", connection.
		 * \return filter expression that calls the given unary \a function_name
		 * taking this variable as \a arg1.
		 */
		RDFFilter filter(QString const &function_name) const;

		/*!
		 * \ref unbound_filters "Assertion expression", connection.
		 * \return filter expression that calls the given unary \a function_name
		 * taking this variable as \a arg1 and the given \a arg2 as the other argument.
		 */
		RDFFilter filter(QString const &function_name, RDFVariable const &arg2) const;

		/*!
		 * \ref unbound_filters "Assertion expression", connection.
		 * \return filter expression that calls the given unary \a function_name
		 * taking this variable as \a arg1, and the given \a arg2 and \a arg3 as the other arguments.
		 */
		RDFFilter filter(QString const &function_name, RDFVariable const &arg2, RDFVariable const &arg3) const;

		/*!
		 * \ref unbound_filters "Assertion expression", connection.
		 * \return filter expression that calls the given unary \a function_name
		 * taking this variable as \a arg1, and the given \a args_tail as the remaining arguments.
		 */
		RDFFilter filter(QString const &function_name, RDFVariableList const &args_tail) const;

		/*!
		 * \ref unbound_filters "Assertion expression", connection.
		 * \return filter expression that calls the given unary \a function
		 * taking this variable as \a arg1.
		 */
		RDFFilter function(RDFVariable const &function) const;

		//! \overload
			template<typename Function_>
		RDFFilter function() const;

		/*!
		 * \ref unbound_filters "Assertion expression", connection.
		 * \return filter expression that calls the given unary \a function
		 * taking this variable as \a arg1.
		 */
		RDFFilter function(RDFVariable const &function, RDFVariable const &arg2) const;

		//! \overload
			template<typename Function_>
		RDFFilter function(RDFVariable const &arg2) const;

		/*!
		 * \ref unbound_filters "Assertion expression", connection.
		 * \return filter expression that calls the given unary \a function
		 * taking this variable as \a arg1.
		 */
		RDFFilter function(RDFVariable const &function, RDFVariable const &arg2, RDFVariable const &arg3) const;

		//! \overload
			template<typename Function_>
		RDFFilter function(RDFVariable const &arg2, RDFVariable const &arg3) const;

		/*!
		 * \ref unbound_filters "Assertion expression", connection.
		 * \return filter expression that calls the given unary \a function
		 * taking this variable as \a arg1, and the given \a args_tail as the remaining arguments.
		 */
		RDFFilter function(RDFVariable const &function, RDFVariableList const &args_tail) const;

		//! \overload
			template<typename Function_>
		RDFFilter function(RDFVariableList const &args_tail) const;



		/*!
		 * \ref unbound_filters "Assertion expression".
		 * \return assertion expression asserting that this variable is
		 * bound to a resource ie. not null. Makes sense typically only
		 * when the variable appears in some optional clause.
		 */
		RDFFilter isBound() const;

		/*!
		 * Convenience assertion that the optional property this variable represents, exists in this context.
		 * If this variable doesn't represent an optional property, behaviour is undefined.
		 */
		inline RDFFilter exists() const;

		/*!
		 * Convenience assertion that the optional property this variable represents, doesnt exist in this context.
		 * If this variable doesn't represent an optional property, behaviour is undefined.
		 */
		inline RDFFilter doesntExist() const;

		friend QDebug Q_DECL_EXPORT operator<<(QDebug s, RDFVariable const &value);

		struct Data;
		QSharedDataPointer<Data> d;
	protected:
		explicit RDFVariable(Data *);
		static Data *clone(Data const *);
	};

#define SOPRANOLIVE_DECLARE_VAR_CLASS(VarClassName_, VarInitializer) \
	struct VarClassName_ \
		: VarClassBase<IriClassName_> \
	{ \
		static RDFVariable iri() { return RDFVariable(VarIdentifier); }; \
	};

	class Q_DECL_EXPORT RDFFilter
		: public RDFVariable
	{
	public:
		RDFFilter(LiteralValue const &constant);
		RDFFilter(RDFVariable const &constant);
		RDFFilter(RDFFilter const &cp);
		~RDFFilter();

		/*!
		 * Assigns another variable to this variable, without affecting
		 * underlying variable graph or constraints.
		 * Analoguous to the conventional "a = b;" idiom.
		 */
		void metaAssign(RDFFilter const &rhs);

		void useFilterIn(RDFPattern const * = 0) const;
		void disable() const;
		void enable() const;

		RDFVariable firstVar() const;

		inline RDFFilter &operator=(RDFVariable const &alias) { RDFVariable::operator=(alias); return *this; }
		struct Data;
	protected:
		friend class RDFVariable;
		explicit RDFFilter(Data *);
	private:
		// prevents splicing assignment of non-RDFFilter types
		using RDFVariable::metaAssign;
	};

	/*!
	 * \ref unbound_filters "Assertion expression".
	 * Operator shortcut for \ref RDFVariable::not_
	 */
	inline RDFFilter operator!(RDFFilter const &var) { return var.not_(); }
	/*!
	 * \ref unbound_filters "Assertion expression".
	 * Operator shortcut for \ref RDFVariable::and_
	 */
	inline RDFFilter operator&&(RDFFilter const &lhs, RDFFilter const &rhs) { return lhs.and_(rhs); }
	/*!
	 * \ref unbound_filters "Assertion expression".
	 * Operator shortcut for \ref RDFVariable::or_
	 */
	inline RDFFilter operator||(RDFFilter const &lhs, RDFFilter const &rhs) { return lhs.or_(rhs); }

	/*!
	 * \ref unbound_filters "Assertion expression", connection.
	 * Operator shortcut for \ref RDFVariable::equal
	 */
	inline RDFFilter operator==(RDFVariable const &lhs, RDFVariable const &rhs) { return lhs.equal(rhs); }
	/*!
	 * \ref unbound_filters "Assertion expression", connection.
	 * Operator shortcut for \ref RDFVariable::notEqual
	 */
	inline RDFFilter operator!=(RDFVariable const &lhs, RDFVariable const &rhs) { return lhs.notEqual(rhs); }
	/*!
	 * \ref unbound_filters "Assertion expression", connection.
	 * Operator shortcut for \ref RDFVariable::less
	 */
	inline RDFFilter operator<(RDFVariable const &lhs, RDFVariable const &rhs) { return lhs.less(rhs); }
	/*!
	 * \ref unbound_filters "Assertion expression", connection.
	 * Operator shortcut for \ref RDFVariable::greater
	 */
	inline RDFFilter operator>(RDFVariable const &lhs, RDFVariable const &rhs) { return lhs.greater(rhs); }
	/*!
	 * \ref unbound_filters "Assertion expression", connection.
	 * Operator shortcut for \ref RDFVariable::lessOrEqual
	 */
	inline RDFFilter operator<=(RDFVariable const &lhs, RDFVariable const &rhs) { return lhs.lessOrEqual(rhs); }
	/*!
	 * \ref unbound_filters "Assertion expression", connection.
	 * Operator shortcut for \ref RDFVariable::greaterOrEqual
	 */
	inline RDFFilter operator>=(RDFVariable const &lhs, RDFVariable const &rhs) { return lhs.greaterOrEqual(rhs); }

	/*!
	 * \ref unbound_filters "Arithmetic expression".
	 * Operator shortcut for \ref RDFVariable::inv
	 */
	inline RDFVariable operator-(RDFVariable const &var) { return var.inv(); }
	/*!
	 * \ref unbound_filters "Arithmetic expression", connection.
	 * Operator shortcut for \ref RDFVariable::add
	 */
	inline RDFVariable operator+(RDFVariable const &lhs, RDFVariable const &rhs) { return lhs.add(rhs); }
	/*!
	 * \ref unbound_filters "Arithmetic expression", connection.
	 * Operator shortcut for \ref RDFVariable::sub
	 */
	inline RDFVariable operator-(RDFVariable const &lhs, RDFVariable const &rhs) { return lhs.sub(rhs); }
	/*!
	 * \ref unbound_filters "Arithmetic expression", connection.
	 * Operator shortcut for \ref RDFVariable::mul
	 */
	inline RDFVariable operator*(RDFVariable const &lhs, RDFVariable const &rhs) { return lhs.mul(rhs); }
	/*!
	 * \ref unbound_filters "Arithmetic expression", connection.
	 * Operator shortcut for \ref RDFVariable::div
	 */
	inline RDFVariable operator/(RDFVariable const &lhs, RDFVariable const &rhs) { return lhs.div(rhs); }

	/*!
	 * A one-way connection class to another RDFVariable.
	 * RDFVariableLink acts as an alias to the target, so all constraints of
	 * the target affect the RDFVariableLink as well. Constraints can be
	 * added to RDFVariableLink in the same way as for a normal RDFVariable, but these
	 * constraints do not propagate to the target. Target can also be changed.
	 * Note! A circular reference can be created with VariableLink's which
	 * will result in a memory leak. You should clear all links by setting
	 * their target to empty RDFVariable before discarding them.
	 */
	class Q_DECL_EXPORT RDFVariableLink
		: public RDFVariable
	{
	public:
		/*!
		 * Default initialized to empty state.
		 */
		RDFVariableLink();

		/*!
		 * The link target is set to the given \a target.
		 */
		RDFVariableLink(RDFVariable const &target);

		/*!
		 * Copy constructor, shares the same link.
		 */
		RDFVariableLink(RDFVariableLink const &cp);

		/*!
		 * Assigns another variablelink to this variablelink, without affecting
		 * underlying variable graph or constraints.
		 * Analoguous to the conventional "a = b;" idiom.
		 */
		void metaAssign(RDFVariableLink const &rhs);

		/*!
		 * One-way connection.
		 * Change the target variable to the given \a new_link_target.
		 */
		void switchTarget(RDFVariable const &new_link_target = RDFVariable());

		inline RDFVariableLink &operator=(RDFVariable const &alias) { RDFVariable::operator=(alias); return *this; }


		struct Data;
	protected:
		friend class RDFVariable;
		explicit RDFVariableLink(Data *);
	private:
		// prevent slicing assignment of non-RDFVariableLink objects.
		using RDFVariable::metaAssign;
	};

	class RDFVariableStatement;
	typedef RDFVariableStatement RDFStatement;

	/*!
	 * An unbound statement template.
	 * \sa RDFUpdate::addInsertion, RDFUpdate::addDeletion, RDFUpdate::addModification
	 */
	class Q_DECL_EXPORT RDFVariableStatement
	{
	public:
		RDFVariableStatement( RDFVariable const &subject = RDFVariable()
							, RDFVariable const &predicate = RDFVariable()
							, RDFVariable const &object = RDFVariable());

		RDFStatement deepCopy(RDFVariable::DeepCopier const &copier = RDFVariable::DeepCopier()) const;
		RDFStatement linkCopy() const;

		void setSubject(RDFVariable const &subject);
		void setPredicate(RDFVariable const &predicate);
		void setObject(RDFVariable const &object);
		RDFVariable subject() const;
		RDFVariable predicate() const;
		RDFVariable object() const;

		//! \return true is all triple parts are definite
		bool isDefinite() const;

		//! \return true if at least one triple part is constrained blank
		bool hasConstrainedBlanks() const;

		//! \deprecated Use hasConstrainedBlanks
		SOPRANO_DEPRECATED bool hasConstraints() const;

		//! \return true if at least one triple part is unconstained blank
		bool hasUnconstrainedBlanks() const;

		//! \return true if at least one triple part is empty
		bool hasEmpty() const;

		friend QDebug Q_DECL_EXPORT operator<<(QDebug s, RDFStatement const &value);
	private:
		RDFVariable subject_, predicate_, object_;
	};
	typedef QList<RDFStatement> RDFVariableStatementList;
	typedef QList<RDFStatement> RDFStatementList;

	typedef QList<RDFProperty> RDFPropertyList;
	/*!
	 * Represents a property browse relation from source node to target node across a triple.
	 * The target role is stored in the strategy as RDFStrategy::Object or RDFStrategy::Subject.
	 * We say that with RDFStrategy::Object the property is an object property, and it means that
	 * the property starts from subject and traverses through predicate to object. Conversely,
	 * if the property is a subject property it is denoted with RDFStrategy::Subject strategy,
	 * and the property starts from a subject and traverses through predicate to the subject.
	 * An object property is sometimes referred to as a forward property, as the typical way
	 * of thinking is that properties start from a subject and are traversed to object.
	 * Similarily, a subject property is referred to as reverse property, as it moves to the
	 * opposite direction than normally.
	 * \n
	 * \n RDFProperty also stores other strategy flags and a shared parent reference for possible
	 * models that are spawned to represent the target.
	 */
#ifndef GENERATING_DOXYGEN_DOCUMENTATION
	class Q_DECL_EXPORT RDFPropertyData
#else
	class RDFProperty
#endif
	{
	public:
		explicit RDFPropertyData
		               ( RDFVariable const &source, RDFVariable const &predicate, RDFVariable const &target
		               , RDFStrategyFlags strategy = RDFStrategy::Disabled
		               , QSharedPointer<QObject> const &parent = QSharedPointer<QObject>()
		               , bool is_triple_bound = false);

		explicit RDFPropertyData( RDFVariable const &predicate = RDFVariable()
		               , RDFVariable const &target = RDFVariable()
		               , RDFStrategyFlags strategy = RDFStrategy::Disabled
		               , QSharedPointer<QObject> const &parent = QSharedPointer<QObject>());
		RDFPropertyData(RDFProperty const &cp);
		~RDFPropertyData();

		void clear();
		void swap(RDFProperty &other);

		RDFProperty &operator=(RDFProperty const &rhs);

		RDFProperty deepCopy(RDFVariable::DeepCopier const &copier = RDFVariable::DeepCopier()) const;

		RDFProperty linkCopy() const;

		static RDFProperty fromVariable(RDFVariable const &variable = RDFVariable()
				, RDFStrategyFlags strategy = RDFStrategy::Disabled
				, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>())
		{
			return RDFProperty(RDFVariable(), variable, strategy, parent);
		}

		static RDFProperty fromObjectOf(RDFVariable const &predicate = RDFVariable()
				, RDFVariable const &object_info = RDFVariable()
				, RDFStrategyFlags strategy = RDFStrategy::Disabled
				, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>())
		{
			return RDFProperty(predicate, object_info, strategy | RDFStrategy::PredicateObject, parent);
		}
		static RDFProperty fromSubjectOf(RDFVariable const &predicate = RDFVariable()
				, RDFVariable const &subject_info = RDFVariable()
				, RDFStrategyFlags strategy = RDFStrategy::Disabled
				, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>())
		{
			return RDFProperty(predicate, subject_info, strategy | RDFStrategy::SubjectPredicate, parent);
		}

		static RDFProperty fromObjectOf(RDFStatement const &statement
				, RDFStrategyFlags strategy = RDFStrategy::Disabled
				, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>());

		static RDFProperty fromSubjectOf(RDFStatement const &statement
				, RDFStrategyFlags strategy = RDFStrategy::Disabled
				, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>());

			template<typename Property_>
		static RDFProperty fromObjectOf(RDFVariable const &object_info
				, RDFStrategyFlags strategy = RDFStrategy::Disabled
				, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>())
		{
			Detail::RDFPropertyChain<Property_> chain;
			return fromObjectOf(chain, object_info, strategy, parent);
		}

			template<typename Property_>
		static RDFProperty fromSubjectOf(RDFVariable const &subject_info
				, RDFStrategyFlags strategy = RDFStrategy::Disabled
				, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>())
		{
			Detail::RDFPropertyChain<Property_> chain;
			return fromSubjectOf(chain, subject_info, strategy, parent);
		}

			template<typename Property_, typename Object_>
		static RDFProperty fromObjectOf(RDFStrategyFlags strategy = RDFStrategy::Disabled
				, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>())
		{
			Detail::RDFPropertyChain<Property_> chain;
			return fromObjectOf(chain, RDFVariable::fromInstance<Object_>(), strategy, parent);
		}

			template<typename Property_, typename Subject_>
		static RDFProperty fromSubjectOf(RDFStrategyFlags strategy = RDFStrategy::Disabled
				, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>())
		{
			Detail::RDFPropertyChain<Property_> chain;
			return fromSubjectOf(chain, RDFVariable::fromInstance<Subject_>(), strategy, parent);
		}

			template<typename PropertyChain_>
		static RDFProperty fromObjectOf(Detail::RDFPropertyChain<PropertyChain_> chain
				, RDFVariable const &object_info = RDFVariable()
				, RDFStrategyFlags strategy = RDFStrategy::Disabled
				, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>())
		{
			bool chained = Detail::RDFPropertyChain<PropertyChain_>::BaseStrategy & RDFStrategy::ChainedProperty;
			object_info.merge(chained ? chain.bind() : chain.target());
			object_info.isOfType<typename PropertyChain_::Range>(false, RDFStrategy::DerivedProperty);
			chain.source().template isOfType<typename PropertyChain_::Domain>(false, RDFStrategy::DerivedProperty);
			return RDFProperty(chain.source(), PropertyChain_::iri(), object_info
					, strategy | Detail::RDFPropertyChain<PropertyChain_>::BaseStrategy
						| RDFStrategy::PredicateObject, parent, chained);
		}

			template<typename PropertyChain_>
		static RDFProperty fromSubjectOf(Detail::RDFPropertyChain<PropertyChain_> chain
				, RDFVariable const &subject_info = RDFVariable()
				, RDFStrategyFlags strategy = RDFStrategy::Disabled
				, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>())
		{
			bool chained = Detail::RDFPropertyChain<PropertyChain_>::BaseStrategy & RDFStrategy::ChainedProperty;
			subject_info.merge(chained ? chain.bindReverse() : chain.source());
			subject_info.isOfType<typename PropertyChain_::Domain>(false, RDFStrategy::DerivedProperty);
			chain.target().template isOfType<typename PropertyChain_::Range>(false, RDFStrategy::DerivedProperty);
			return RDFProperty(chain.target(), PropertyChain_::iri(), subject_info
					, strategy | Detail::RDFPropertyChain<PropertyChain_>::BaseStrategy
						| RDFStrategy::SubjectPredicate, parent, chained);
		}

		// do not use these. use linkCopy or manual links instead.
		SOPRANO_DEPRECATED static RDFProperty ofLinkedObject(RDFVariable const &predicate = RDFVariable()
				, RDFVariable const &object_info = RDFVariable()
				, RDFStrategyFlags strategy = RDFStrategy::Disabled
				, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>())
		{
			return fromObjectOf(RDFVariableLink(predicate), RDFVariableLink(object_info), strategy, parent);
		}

		// do not use these. use linkCopy or manual links instead.
		SOPRANO_DEPRECATED static RDFProperty ofLinkedSubject(RDFVariable const &predicate = RDFVariable()
				, RDFVariable const &subject_info = RDFVariable()
				, RDFStrategyFlags strategy = RDFStrategy::Disabled
				, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>())
		{
			return fromSubjectOf(RDFVariableLink(predicate), RDFVariableLink(subject_info), strategy, parent);
		}

		// do not use these. use linkCopy or manual links instead.
			template<typename Property_>
		SOPRANO_DEPRECATED static RDFProperty ofLinkedObject(RDFVariable const &object_info = RDFVariable()
				, RDFStrategyFlags strategy = RDFStrategy::Disabled
				, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>())
		{
			return fromObjectOf<Property_>(RDFVariableLink(object_info), strategy | Property_::BaseStrategy, parent);
		}

		// do not use these. use linkCopy or manual links instead.
			template<typename Property_>
		SOPRANO_DEPRECATED static RDFProperty ofLinkedSubject(RDFVariable const &subject_info = RDFVariable()
				, RDFStrategyFlags strategy = RDFStrategy::Disabled
				, QSharedPointer<QObject> const &parent = QSharedPointer<QObject>())
		{
			return fromSubjectOf<Property_>(RDFVariableLink(subject_info), strategy | Property_::BaseStrategy, parent);
		}

		void setSource(RDFVariable const &source);
		RDFVariable source() const;
		void setPredicate(RDFVariable const &predicate);
		RDFVariable predicate() const;
		void setTarget(RDFVariable const &target);
		RDFVariable target() const;

#if (QTTRACKER_SUPPORT_VER <= 603)
		//! \deprecated Use \ref setTarget instead
		SOPRANO_DEPRECATED void setProperty(RDFVariable const &property);
		//! \deprecated Use \ref target instead
		SOPRANO_DEPRECATED RDFVariable property() const;
		//! \deprecated Use \ref setTarget instead
		SOPRANO_DEPRECATED void setObject(RDFVariable const &object);
		//! \deprecated Use \ref target instead
		SOPRANO_DEPRECATED RDFVariable object() const;
		//! \deprecated Use \ref setTarget instead
		SOPRANO_DEPRECATED void setSubject(RDFVariable const &subject);
		//! \deprecated Use \ref target instead
		SOPRANO_DEPRECATED RDFVariable subject() const;
		//! \deprecated Use \ref setTarget instead
		SOPRANO_DEPRECATED void setVariable(RDFVariable const &variable);
		//! \deprecated Use \ref target instead
		SOPRANO_DEPRECATED RDFVariable variable() const;
#endif

		void setParent(QSharedPointer<QObject> const &parent);
		QSharedPointer<QObject> parent() const;

		void setStrategy(RDFStrategyFlags const &strategy);
		void enableStrategyFlags(RDFStrategyFlags const &strategy);
		void disableStrategyFlags(RDFStrategyFlags const &strategy);
		RDFStrategyFlags strategy() const;

		/*!
		 * Applies this property to the given \a source_node and returns the
		 * RDFVariable corresponding to the traversed target node. Does not
		 * change this RDFProperty variable associations.
		 */
		RDFVariable traverse(RDFVariable const &source) const;
		/*!
		 * Binds this property to the given \a source_node and returns the
		 * RDFVariable corresponding to the traversed target node. Changes
		 * the variable associations of this RDFProperty.
		 */
		RDFVariable bind(RDFVariable const &source);

		/*!
		 * \return a statement formed from source, predicate and target. The property predicate
		 * is always used as the statement predicate. If we are an object property, subject is
		 * the source, and object is the target. Otherwise, we're a subject property, and object
		 * is the source and subject is the target.
		 */
		RDFStatement asStatement() const;

		/*!
		 * \return a statement formed by completing the predicate and
		 * subject/object with the given \a remaining_role variable as
		 * object/subject, respectively.
		 */
		RDFStatement asStatementWith(RDFVariable const &source = RDFVariable()) const;

		/*!
		 * Applies the given \a property_chain to the given \a source_node
		 * and returns the RDFVariable corresponding to the traversed target
		 * node. Does not change the variable associations of any properties
		 * in the property_chain.
		 */
		static RDFVariable traverse(RDFPropertyList const &property_chain, RDFVariable const &source);

		/*!
		 * Binds the given \a property_chain to the given \a source_node
		 * and returns the RDFVariable corresponding to the traversed target
		 * node. Changes the variable associations of the property_chain by
		 * binding each entry together.
		 */
		static RDFVariable bind(RDFPropertyList &property_chain, RDFVariable const &source);

#if (QTTRACKER_SUPPORT_VER <= 603)
		//! \deprecated Support version 1~6.3.x. Use RDFProperty::bind instead
		SOPRANO_DEPRECATED RDFVariable bindTriple(RDFVariable const &other_role)
		{
			return other_role.bindProperty(*this);
		}

		//! \deprecated Support version 1~6.3.x. Use separated RDFProperty::linkCopy and RDFProperty::bind instead
		SOPRANO_DEPRECATED RDFProperty linkAndBind(RDFVariable const &other_role) const
		{
			RDFProperty ret = linkCopy();
			ret.bind(other_role);
			return ret;
		}
#endif
		friend QDebug Q_DECL_EXPORT operator<<(QDebug s, RDFProperty const &value);

		struct Data;
	private:
		QSharedDataPointer<Data> d;
	};

	/*!
	 * RDFPattern is used to implement optional and union behavior.
	 * Most of the time one doesn't deal with RDFPattern objects, they are managed behind the scenes, behind individual RDFVariable objects.
	 * Knowledge on how they behave is still important when dealing with optional and union selections.
	 *
	 * RDFPattern represents a group of constraints, which are enforced together.
	 * \n This means that even if one of the constraints fail, all other constraints in the group are considered as having failed also.
	 *
	 * Each RDFVariable has a parent RDFPattern.
	 * \n This affects where constraints on that variable are put, see Rules 1 and 2.
	 *
	 * Even though different RDFVariable instances can be set to be equal, they still can belong to different patterns.
	 * \n This allows control over where constraints are put.
	 *
	 * An RDFPattern can be anonymous or explicit. This allows for joining patterns together.
	 *
	 * \n Rule 1. Whenever a constraint affecting only one variable is made, that constraint is placed into the parent pattern of that variable.
	 * \n Rule 2. Whenever a connecting constraint is placed between two variables, the constraint is placed into the pattern of the left hand side variable of the connection.
	 * \n Rule 3. Whenever either side of a connection is an anonymous pattern, it is fused into the other without affecting the anonymous/explicit state of the other.
	 * \n Rule 4. Whenever an optional or union pattern is created, both the originating and the resulting patterns are marked explicit.
	 * \sa layer_unbound
	 */
	class Q_DECL_EXPORT RDFPattern
	{
	public:
		RDFPattern();
		RDFPattern(RDFPattern const &cp);
		~RDFPattern();

		//! \return a deep copy of this graph
		RDFPattern deepCopy(RDFVariable::DeepCopier const &copier = RDFVariable::DeepCopier()) const;

		enum { TopmostParent = -1 };

		//! \return the index'th parent of this pattern if such exists, topmost parent otherwise.
		RDFPattern parent(int index = 1) const;

		/*!
		 * \return a new unconstrained variable belonging to this pattern.
		 */
		RDFVariable variable(QString explicit_name = QString()) const;

		/*!
		 * \return an alias of the given \a variable belonging to this pattern.
		 */
		RDFVariable variable(RDFVariable const &variable) const;

		/*!
		 * Use the given \a filter in this pattern
		 */
		void useFilter(RDFFilter const &filter) const;

		/*!
		 * Set this pattern as the parent pattern of the range of variables defined by the given \a begin and \a end
		 */
			template<typename Iter>
		inline void useVariables(Iter begin, Iter const &end)
		{ while(begin != end) (begin++)->setPattern(*this); }

		/*!
		 * Set this pattern as the parent pattern of all variables in the given \a container
		 */
			template<typename Container_>
		inline void useVariables(Container_ const& container)
		{ usesVariables(container.begin(), container.end()); }

		/*!
		 * \return a new pattern which is in a child relationship with this pattern.
		 * All constraints in the child pattern affect parent, however union patterns of the child
		 * can be generated.
		 */
		RDFPattern child() const;

		//! Set the given \a child pattern to be a child of this pattern
		RDFPattern child(RDFPattern const &child) const;

		/*!
		 * \return a new pattern which is in an union-relationship with this pattern.
		 */
		RDFPattern union_() const;
		//! Set the given \a union_ pattern to be in a union relationship with this pattern
		RDFPattern union_(RDFPattern const &union_) const;

		/*!
		 * \return a new pattern which is in a child role of optional-relationship with this pattern.
		 */
		RDFPattern optional() const;
		//! Set the given \a optional pattern to be in a child role of a optional-relationship with this pattern
		RDFPattern optional(RDFPattern const &optional) const;

		//! \return the graph association variable of this pattern.
		RDFVariable graph() const;

		//! Set the graph to be an EXISTS graph. If the returned filter is not used, the exists
		//! clause is just added to the existing graph, otherwise the whole graph pattern is
		//! removed from its current context and moved inside the filter context.
		RDFFilter exists() const;

		//! Set the graph to be an NOT EXISTS graph. If the returned filter is not used, the exists
		//! clause is just added to the existing graph, otherwise the whole graph pattern is
		//! removed from its current context and moved inside the filter context.
		RDFFilter notExists() const;

		/*!
		 * \return a new subquery which is a child of this pattern. All
		 * subqueries will be evaluated before their parents, and their
		 * solutions are exported outside.
		 */
		RDFSubSelect subQuery() const;

		struct Data;
		QSharedDataPointer<Data> d;
		RDFPattern &operator=(RDFPattern const &cp);
	protected:
		friend class RDFVariable;
		explicit RDFPattern(Data *);
	};



	/*!
	 * Base class for various queries.
	 * \sa RDFSelect, RDFUpdate
	 */
	class Q_DECL_EXPORT RDFQuery
	{
	public:
		/*! \enum Type
		 * Query type. Only SPARQL and SPARQLUpdate are supported now.
		 */
		enum Type { SPARQL, SPARQLUpdate };

		// TODO: why is getQuery virtual?
		// \return a deep copy of this query
		//RDFQuery deepCopy(RDFVariable::DeepCopier const &copier = RDFVariable::DeepCopier()) const;

		bool isEmpty() const;

		/*!
		 * Add given \a graph to the list of graphs known by this query with
		 * optional \a graph_name.
		 * When a locally unevaluated node is encountered and the source graph of
		 * the node is found on the list of known graphs, the source variable for
		 * that node is expanded inside the query. If not found, the node is evaluated locally.
		 */
		void addKnownGraph(QSharedPointer<RDFGraph> graph, QUrl graph_name = QUrl());

		/*!
		 * \return query as string in the given \a format (onlyRDFQueryRDFQueryRDFQuery SPARQL supported).
		 */
		virtual QString getQuery(int format) const = 0;

		/*!
		 * \return query as string in the specified format (only SPARQL supported).
		 * Also words from the set of given \a reserved_words will not be used in
		 * the generated query.
		 */
		virtual QString getQuery(QStringList reserved_words, int format) const = 0;

		/*!
		 * Add a prefix with the given value into the Query.
		 */
		void prefix(QString prefix, QString value);

		//! return true if this query is an RDFUpdate query
		bool isRDFUpdate() const;

		//! return true if this query is an RDFUpdate query
		bool isRDFSelect() const;

		/*!
		 * \return RDFUpdate query if this query is an update query, a new clear query otherwise
		 */
		RDFUpdate toRDFUpdate() const;
		/*!
		 * \return RDFSelect query if this query is a select query, a new clear query otherwise
		 */
		RDFSelect toRDFSelect() const;


		RDFQuery(RDFQuery const &cp);
		~RDFQuery();
		RDFQuery &operator=(RDFQuery const &rhs);

		struct Data;
		QSharedDataPointer<Data> d;
	protected:
		explicit RDFQuery(Data *d);

		static Data *clone(Data const *);
	};

	/*!
	 * Represents information on a single column of an \ref RDFSelect object.
	 * \sa RDFSelect
	 */
	struct Q_DECL_EXPORT RDFSelectColumn
	{
		RDFSelectColumn(RDFSelectColumn const &cp);
		~RDFSelectColumn();

		//! \return a deep copy of this select column
		RDFSelectColumn deepCopy(RDFVariable::DeepCopier const &copier = RDFVariable::DeepCopier()) const;

		/*!
		 * The Mode of the column.
		 */
		enum
		{ Normal, Count, Sum, Avg, Min, Max
			// qttracker generates the DISTINCT for all, but only Count is explicitly supported
		, Distinct = (1 << 3)
		, CountDistinct = Count | Distinct};

		typedef unsigned Mode;
		//! \return the mode of the column
		int mode() const;

		//! \return the name of the column, as it will appear on the result model header
		QString name() const;

		//! \return the variable bound to this column
		RDFVariable &variable();

		//! \overload
		RDFVariable const &variable() const;

		//! \return the outer variable of this column. If column has no
		//! outer variable, inner variable is returned.
		RDFVariable outerVariable() const;

		RDFSelectColumn create(RDFVariable const &variable, Mode mode = Normal);
		RDFSelectColumn create(RDFVariable const &variable, Mode mode, RDFVariable const &outer);

		struct Data;
		QSharedDataPointer<Data> d;
	protected:
		friend class RDFSelect;
		RDFSelectColumn(Data &d);
	};
	typedef QList<RDFSelectColumn> RDFSelectColumnList;

	/*!
	 * Defines a multi-column selection query.
	 * The query is built by mapping RDFVariables of an existing query
	 * graph into columns. When the selection is executed, different solution
	 * combinations for the query are translated into rows in a result
	 * model, one row per solution. Each value in such a row then represents
	 * the value of the corresponding column RDFVariable in that particular
	 * solution. The whole process is referred to as modeling a query in a
	 * graph.
	 * \n Note that RDFSelect does not constrain the given variables in any
	 * way. This allows several RDFSelects to operate on same RDFVariables.
	 * See \ref RDFSubSelect for subqueries which constrain the variables.
	 * \sa RDFGraph::modelQuery, LiveNodes
	 */
	class Q_DECL_EXPORT RDFSelect
		: public RDFQuery
	{
	public:
		typedef QList<RDFSelectColumn> Columns;

		RDFSelect();
		RDFSelect(RDFSelect const &cp);
		RDFSelect(Columns const &columns);

		//! \return a deep copy of this select
		RDFSelect deepCopy(RDFVariable::DeepCopier const &copier = RDFVariable::DeepCopier()) const;

		/*!
		 * Creates a new column and returns the associated variable
		 * \param column_name the header name of the new column
		 * \return the new variable representing the new column
		 */
		RDFVariable newColumn(QString column_name = QString());
		RDFVariable newColumn(QString column_name, RDFSelectColumn::Mode mode);

		//! \deprecated Use newColumnAs instead
		SOPRANO_DEPRECATED RDFVariable newColumn(RDFVariable const &outer_identity, RDFSelectColumn::Mode mode = RDFSelectColumn::Normal);

		/*!
		 * The generic function for creating a new column with given
		 * \a outer_identity and given \a aggregation_mode.
		 * \return the variable representing the new column
		 * \param outer_identity is used primarily for representing the
		 * results of a sub query in the containing outer query, if the
		 * column is an aggregate or expression query.
		 */
		RDFVariable newColumnAs(RDFVariable const &outer_identity, RDFSelectColumn::Mode mode = RDFSelectColumn::Normal);

		/*!
		 * Creates a new column and returns the associated variable
		 * \param column_name the header name of the new column
		 * \param Type_ type constraint for the new column. Used internally by any models created from this selection.
		 * \return the new variable representing the new column
		 */
			template<typename Type_>
		RDFVariable newColumn(QString column_name = QString(), RDFSelectColumn::Mode mode = RDFSelectColumn::Normal)
		{	RDFVariable ret = RDFVariable::fromType<Type_>(); addColumn(column_name, ret, mode); return ret; }

			template<typename Type_>
		RDFVariable newColumnAs(RDFVariable const &outer_identity, RDFSelectColumn::Mode mode = RDFSelectColumn::Normal)
		{	RDFVariable ret = RDFVariable::fromType<Type_>(); addColumnAs(ret, outer_identity, mode); return ret; }

		/*!
		 * Creates a new count aggregate column and a new variable for it
		 * \param column_name the header name of the new column
		 * \return the new variable representing the new count aggregate column
		 * Note: requires results to be sorted to make any sense
		 */
		RDFVariable newCountColumn(QString column_name = QString());
		RDFVariable newCountColumnAs(RDFVariable const &outer_variable) { return newColumnAs(outer_variable, RDFSelectColumn::Count); }
		RDFVariable newCountDistinctColumn(QString column_name = QString());
		RDFVariable newCountDistinctColumnAs(RDFVariable const &outer_variable) { return newColumnAs(outer_variable, RDFSelectColumn::CountDistinct); }

		/*!
		 * Creates a new sum aggregate column and a new variable for it
		 * \param column_name the header name of the new column
		 * \return the new variable representing the new sum aggregate column
		 * Note: requires results to be sorted to make any sense
		 */
		RDFVariable newSumColumn(QString column_name = QString());
		RDFVariable newSumColumnAs(RDFVariable const &outer_variable) { return newColumnAs(outer_variable, RDFSelectColumn::Sum); }
		/*!
		 * Creates a new avg aggregate column and a new variable for it
		 * \param column_name the header name of the new column
		 * \return the new variable representing the new avg aggregate column
		 * Note: requires results to be sorted to make any sense
		 */
		RDFVariable newAvgColumn(QString column_name = QString());
		RDFVariable newAvgColumnAs(RDFVariable const &outer_variable) { return newColumnAs(outer_variable, RDFSelectColumn::Avg); }
		/*!
		 * Creates a new min aggregate column and a new variable for it
		 * \param column_name the header name of the new column
		 * \return the new variable representing the new min aggregate column
		 * Note: requires results to be sorted to make any sense
		 */
		RDFVariable newMinColumn(QString column_name = QString());
		RDFVariable newMinColumnAs(RDFVariable const &outer_variable) { return newColumnAs(outer_variable, RDFSelectColumn::Min); }
		/*!
		 * Creates a new max aggregate column and a new variable for it
		 * \param column_name the header name of the new column
		 * \return the new variable representing the new max aggregate column
		 * Note: requires results to be sorted to make any sense
		 */
		RDFVariable newMaxColumn(QString column_name = QString());
		RDFVariable newMaxColumnAs(RDFVariable const &outer_variable) { return newColumnAs(outer_variable, RDFSelectColumn::Max); }

		/*!
		 * The generic function for creating a new column with given
		 * \a aggregation_mode and given \a outer_identity.
		 * \param outer_identity is used primarily for representing the
		 * results of a sub query in the containing outer query, if the
		 * column is an aggregate or expression query.
		 * \return this
		 */
		RDFSelect &addColumn(RDFVariable const &column_variable, RDFSelectColumn::Mode mode = RDFSelectColumn::Normal);

		//! \deprecated Use addColumnAs
		SOPRANO_DEPRECATED RDFSelect &addColumn(RDFVariable const &column_variable, RDFVariable const &outer_identity, RDFSelectColumn::Mode mode);

		RDFSelect &addColumnAs(RDFVariable const &column_variable, RDFVariable const &outer_identity, RDFSelectColumn::Mode mode = RDFSelectColumn::Normal);

		/*!
		 * Creates a new column and binds the given \a column_variable to it
		 * \param column_name the header name of the new column
		 * \param optional type constraint for the new column. Used internally by any models created from this selection.
		 * \return this
		 */
		RDFSelect &addColumn(QString column_name, RDFVariable const &column_variable);
		RDFSelect &addColumn(QString column_name, RDFVariable const &column_variable, RDFSelectColumn::Mode mode);

		/*!
		 * Creates a new column and binds the given \a column_variable to it
		 * \param column_name the header name of the new column
		 * \param Type_ type constraint for the new column. Used internally by any models created from this selection.
		 * \return this
		 */
			template<typename Type_>
		RDFSelect &addColumn(QString column_name, RDFVariable const &column_variable = RDFVariable(), RDFSelectColumn::Mode mode = RDFSelectColumn::Normal)
		{ return addColumn(column_variable.isOfType<Type_>(), RDFVariable(column_name), mode); }

		//! \overload
			template<typename Type_>
		RDFSelect &addColumn(RDFVariable const &column_variable, RDFSelectColumn::Mode mode = RDFSelectColumn::Normal)
		{ return addColumn(column_variable.isOfType<Type_>(), RDFVariable::createEmpty(), mode); }

		//! \overload
			template<typename Type_>
		RDFSelect &addColumnAs(RDFVariable const &column_variable, RDFVariable const &outer_identity, RDFSelectColumn::Mode mode = RDFSelectColumn::Normal)
		{ return addColumnAs(column_variable.isOfType<Type_>(), outer_identity, mode); }

		/*!
		 * Creates a new count aggregate column and binds the given \a counted_variable to it
		 * \param column_name the header name of the new column
		 * Note: requires results to be sorted to make any sense
		 * \return this
		 */
		RDFSelect &addCountColumn(QString column_name, RDFVariable const &counted_variable);

		//! \overload
		RDFSelect &addCountColumn(RDFVariable const &counted_variable)
		{ return addColumnAs(counted_variable, RDFVariable::createEmpty(), RDFSelectColumn::Count); }

		//! \overload
		RDFSelect &addCountColumnAs(RDFVariable const &counted_variable, RDFVariable const &outer_identity)
		{ return addColumnAs(counted_variable, outer_identity, RDFSelectColumn::Count); }

		//! \overload
		//! Adds distinct modifier to normal count column.
		RDFSelect &addCountDistinctColumn(QString column_name, RDFVariable const &counted_variable);

		//! \overload
		RDFSelect &addCountDistinctColumn(RDFVariable const &counted_variable)
		{ return addColumnAs(counted_variable, RDFVariable::createEmpty(), RDFSelectColumn::CountDistinct); }

		//! \overload
		RDFSelect &addCountDistinctColumnAs(RDFVariable const &counted_variable, RDFVariable const &outer_identity)
		{ return addColumnAs(counted_variable, outer_identity, RDFSelectColumn::CountDistinct); }

		/*!
		 * Creates a new sum aggregate column and binds the given \a summed_variable to it
		 * \param column_name the header name of the new column
		 * Note: requires results to be sorted to make any sense
		 * \return this
		 */
		RDFSelect &addSumColumn(QString column_name, RDFVariable const &summed_variable);

		//! \overload
		RDFSelect &addSumColumn(RDFVariable const &summed_variable)
		{ return addColumnAs(summed_variable, RDFVariable::createEmpty(), RDFSelectColumn::Sum); }

		//! \overload
		RDFSelect &addSumColumnAs(RDFVariable const &summed_variable, RDFVariable const &outer_identity)
		{ return addColumnAs(summed_variable, outer_identity, RDFSelectColumn::Sum); }

		/*!
		 * Creates a new avg aggregate column and binds the given \a averaged_variable to it
		 * \param column_name the header name of the new column
		 * Note: requires results to be sorted to make any sense
		 * \return this
		 */
		RDFSelect &addAvgColumn(QString column_name, RDFVariable const &averaged_variable);

		//! \overload
		RDFSelect &addAvgColumn(RDFVariable const &averaged_variable)
		{ return addColumnAs(averaged_variable, RDFVariable::createEmpty(), RDFSelectColumn::Avg); }

		//! \overload
		RDFSelect &addAvgColumnAs(RDFVariable const &averaged_variable, RDFVariable const &outer_identity)
		{ return addColumnAs(averaged_variable, outer_identity, RDFSelectColumn::Avg); }

		/*!
		 * Creates a new min aggregate column and binds the given \a minned_variable to it
		 * \param column_name the header name of the new column
		 * Note: requires results to be sorted to make any sense
		 * \return this
		 */
		RDFSelect &addMinColumn(QString column_name, RDFVariable const &minned_variable);

		//! \overload
		RDFSelect &addMinColumn(RDFVariable const &minned_variable)
		{ return addColumnAs(minned_variable, RDFVariable::createEmpty(), RDFSelectColumn::Min); }

		//! \overload
		RDFSelect &addMinColumnAs(RDFVariable const &minned_variable, RDFVariable const &outer_identity)
		{ return addColumnAs(minned_variable, outer_identity, RDFSelectColumn::Min); }

		/*!
		 * Creates a new max aggregate column and binds the given \a maxed_variable to it
		 * \param column_name the header name of the new column
		 * Note: requires results to be sorted to make any sense
		 * \return this
		 */
		RDFSelect &addMaxColumn(QString column_name, RDFVariable const &maxed_variable);

		//! \overload
		RDFSelect &addMaxColumn(RDFVariable const &maxed_variable)
		{ return addColumnAs(maxed_variable, RDFVariable::createEmpty(), RDFSelectColumn::Max); }

		//! \overload
		RDFSelect &addMaxColumnAs(RDFVariable const &maxed_variable, RDFVariable const &outer_identity)
		{ return addColumnAs(maxed_variable, outer_identity, RDFSelectColumn::Max); }


		/*!
		 * \return a reference to mutable column set of this selection
		 */
		Columns &columns();
		/*!
		 * \return a reference to read-only column set of this selection
		 */
		Columns const &columns() const;

		//! \return the top-level pattern of this query
		RDFPattern pattern() const;

		//! \return an non-column-bound variable appearing in query with
		//! optionally given \a explicit_name
		RDFVariable variable(QString const &explicit_name = QString()) const;

			template<typename Type_>
		RDFVariable variable(QString const &explicit_name = QString()) const
		{ RDFVariable ret = variable(explicit_name); ret.isOfType<Type_>(); return ret; }

		RDFVariable variable(RDFVariable const &variable) const;

		//! \return the variable representing the given \a column
		RDFVariable variable(int column) const;

		/*!
		 * \return a list of variables representing the columns, for which
		 * the strategy masked by the given \a mask matches the given \a flags
		 * If mask is null, it is set to flags by default.
		 */
		RDFVariableList variables(RDFStrategyFlags flags = 0, RDFStrategyFlags mask = 0) const;

		/*!
		 * Specify distinct option of the selection.
		 * If the selection is specified distinct, consequtive identical rows are merged.
		 * \param is_distinct whether the selection should be distinct or not
		 * Note: requires results to be sorted to make any sense
		 * If set, overrides reduced state
		 * \return this
		 */
		RDFSelect &distinct(bool is_distinct = true);
		//! \return true if distinct option is set; false otherwise
		bool isDistinct() const;

		/*!
		 * Specify reduced option of the selection.
		 * If the selection is specified reduced, consequtive identical rows might be merged.
		 * \param is_reduced whether the selection should be reduced or not
		 * Note: requires results to be sorted to make any sense
		 * If distinct is set, overrides reduced state
		 * \return this
		 */
		RDFSelect &reduced(bool is_reduced = true);
		//! \return true if reduced option is set; false otherwise
		bool isReduced() const;

		/*!
		 * Limits the number of rows in the result set to given \a limit, where 0
		 * means no limit.
		 * Note: typically results should be sorted for this to make any sense
		 * Note: you must use the NoLimit enum, as on future abi break, the constant
		 * representing no limit is going to be something else.
		 * \return this
		 */
		enum { NoLimit = 0 };
		RDFSelect &limit(int limit);
		//! \return limit of rows in the result set; 0 if no limit is set
		int getLimit() const;

		/*!
		 * Requests the result set to not contain the first given \a offset rows.
		 * Note: typically results should be sorted for this to make any sense
		 * \return this
		 */
		RDFSelect &offset(int offset);
		//! \return offset of rows in the result set
		int getOffset() const;

		/*!
		 * Requests the result set to be grouped by the given \a variable or \a column (zero-based index).
		 * The variable must have been added as a column before calling this function.
		 * Can be called multiple times to specify secondary grouping conditions.
		 * \return this
		 */
		RDFSelect &groupBy(RDFVariable const &variable);
		//! \overload
		RDFSelect &groupBy(unsigned column);
		//! \return list of indices to columns defining the group-by order
		QVector<int> getGroupBys() const;
		//! Set list of indices to columns defining the group-by order
		void setGroupBys(QVector<int> const &group_bys);
		//! \overload
		RDFSelect &insertGroupBy(unsigned group_by_loc, unsigned column);
		//! \overload
		RDFSelect &insertGroupBy(unsigned group_by_loc, RDFVariable const &variable);

		/*!
		 * Requests the result set to be ordered by the given \a variable or \a column (zero-based index).
		 * \param ascending if true, sorting order is ascending; otherwise descending.
		 * The ordering can be specified by a variable not representing a column, but
		 * the variable must have been added as a column before calling this function.
		 * Can be called multiple times to specify secondary ordering conditions.
		 * \return this
		 */

		enum { Descending = 0, Ascending = 1 };
		typedef bool OrderMode;

		RDFSelect &orderBy(RDFVariable const &variable, OrderMode is_ascending = Ascending);
		//! \overload
		RDFSelect &orderBy(unsigned column, OrderMode is_ascending = Ascending);

		typedef QVector<QPair<int, OrderMode> > OrderByInfo;

		//! \return list of indices to columns defining the order-by order
		// if an index is negative, the ordering is not specified according to a column but
		// an internal variable. The variable can be obtained by giving the
		// index to variable(index) function.
		OrderByInfo getOrderBys() const;
		//! Set list of indices to columns defining the order-by order
		void setOrderBys(OrderByInfo const &group_bys);
		//! \overload
		RDFSelect &insertOrderBy
				( unsigned order_by_loc
				, unsigned column, OrderMode is_ascending = Ascending);
		//! \overload
		RDFSelect &insertOrderBy
				( unsigned order_by_loc
				, RDFVariable const &variable, OrderMode is_ascending = Ascending);

		QString getQuery(int format = SPARQL) const;
		QString getQuery(QStringList reserved_words, int format = SPARQL) const;

		struct Data;
		~RDFSelect();
	protected:
		friend class RDFQuery;
		RDFSelect(Data *d);
	public:
		Data *d_func();
		Data const *d_func() const;
	};

	/*!
	 * A subquery class. Like RDFSelect, it represents a table based query,
	 * but unlike RDFSelect, it constrains the RDFVariables so that the
	 * resulting solutions are limited by the solutions the subquery
	 * would have if it was executed separately. Thus where adding new
	 * RDFSelect objects on the same RDFVariable graph is transparent to
	 * other RDFSelects, adding new RDFSubSelects is not.
	 * Note: All new column variables can be used outside the subselection,
	 * but as an important exception for now, regular variables used inside
	 * the subquery should not be used outside it.
	 */
	class Q_DECL_EXPORT RDFSubSelect
		: public RDFSelect
	{
	public:
		RDFSubSelect();
		RDFSubSelect(RDFSubSelect const &cp);

		//! \return a deep copy of this subselect
		RDFSubSelect deepCopy(RDFVariable::DeepCopier const &copier = RDFVariable::DeepCopier()) const;

		//! \return the toplevel pattern of this query
		RDFPattern pattern() const;

		//! \return the subselection as an expression that takes on the
		//! values of the first subselected column
		RDFFilter asExpression() const;

		struct Data;
		~RDFSubSelect();
	protected:
		friend class RDFQuery;
		RDFSubSelect(Data *d);
	};


	/*!
	 * Defines an update query.
	 * Formed as a sequence of subclauses, where each subclause is a combination of a deletion followed by insertion.
	 * Each deletion and insertion is performed by binding the given graph pattern under \ref RDFStatement as a selection, and then using the resulting set in the statements to form the insertions and deletions.
	 * Note that the binding for insertion happens before the deletion is executed.
	 * Used by \ref RDFGraph::executeQuery
	 * \sa RDFQuery
	 */
	class Q_DECL_EXPORT RDFUpdate
		: public RDFQuery
	{
	public:
		friend class RDFQuery;
		struct Data;
	protected:
		RDFUpdate(Data *d);
	public:
		Data *d_func();
		Data const *d_func() const;

		struct Operation
		{
		public:
			//! Enum for the Operation type.
			enum ClauseType
			{	Insert, Delete, Modify
			,	Definite = 4
			,	DefiniteInsert = Insert | Definite
			,	DefiniteDelete = Delete | Definite
			,	DefiniteDeletion = DefiniteDelete // inconsistent, dont use, retained to not cause breaks
			,	Silent = 8
			, 	SilentInsert = Insert | Silent
			,	SilentDelete = Delete | Silent
			,	SilentModify = Modify | Silent
			, 	SilentDefiniteInsert = Silent | DefiniteInsert
			,	SilentDefiniteDelete = Silent | DefiniteDelete
			,	SilentDefiniteModify = Silent | SilentModify
			};
		private:
			mutable ClauseType type_;
			RDFStatementList deletes_, inserts_;
			Node graph_;
			friend class Data;

		public:
			//! \return true if the operation does not contain variables, ie if it has an empty
			//! WHERE clause
			bool isDefinite() const;

			//! \return true if the operation is a silent operation. See \ref setSilent for details.
			bool isSilent() const;

			//! Set the operation to \a silent and return this. If a silent operation fails, it wont
			//! generate errors and the full update will proceed executing subsequent operations.
			Operation &setSilent(bool silent = true);

			//! \return the type of the operation.
			ClauseType type() const;

			//! \return delete statements
			RDFStatementList deletes() const;

			//! \return insert statements
			RDFStatementList inserts() const;

			//! \return graph node
			Node graph() const;

			Operation(RDFStatementList const &deletes, RDFStatementList const &inserts, ClauseType type, Node const &graph);

			//! \return a deep copy of the operation
			Operation deepCopy(RDFVariable::DeepCopier const &copier = RDFVariable::DeepCopier()) const;

			/*!
			 * \return a INSERT operation which inserts all given \a inserts statements
			 * into given \a graph, or default graph if \a graph is omitted.
			 */
			static Operation insertion(RDFStatementList const &inserts, Node const &graph = Node());

			/*!
			 * \return a DELETE operation which deletes all given \a deletes statements
			 * from given \a graph, or default graph if \a graph is omitted.
			 */
			static Operation deletion(RDFStatementList const &deletes, Node const &graph = Node());

			/*!
			 * \return a modify operation which first deletes all given \a deletes and
			 * then inserts all given \a inserts statements on given \a graph, or default
			 * graph if \a graph is omitted.
			 */
			static Operation modification(RDFStatementList const &deletes, RDFStatementList const &inserts, Node const &graph = Node());
		};
		typedef QList<Operation> OperationList;

		RDFUpdate();
		RDFUpdate(RDFUpdate const &cp);

		//! \return a deep copy of this update
		RDFUpdate deepCopy(RDFVariable::DeepCopier const &copier = RDFVariable::DeepCopier()) const;

		//! \return the list of operations contained in this update
		OperationList const &operations() const;

		//! Sets the contained operations to given list of \a operations and returns this
		RDFUpdate &setOperations(OperationList const &operations);

		QString getQuery(int format = SPARQLUpdate) const;
		QString getQuery(QStringList reserved_words, int format = SPARQLUpdate) const;


		// TODO: on ABI break: add RDFUpdate & as return type for these functions

		/*!
		 * Add a given \a operation.
		 */
		RDFUpdate &addOperation(Operation const &operation);

		/*!
		 * Add an insertion clause of given \a statement_templates into the optionally speficied \a graph.
		 */
		RDFUpdate &addInsertion(RDFStatementList const &statement_templates, Node const &graph = Node());
		/*!
		 * \overload
		 */
		RDFUpdate &addInsertion(RDFStatement const &statement_template, Node const &graph = Node())
		{ return addOperation(Operation::insertion(RDFStatementList() << statement_template, graph)); }
		/*!
		 * \overload
		 */
		RDFUpdate &addInsertion(RDFVariable const &subject = RDFVariable()
                , RDFVariable const &predicate = RDFVariable()
                , RDFVariable const &object = RDFVariable(), Node const &graph = Node())
		{ return addOperation(Operation::insertion(RDFStatementList() << RDFStatement(subject, predicate, object), graph)); }

		/*!
		 * Add a deletion clause by given \a statement_templates into the optionally given \a graph.
		 */
		RDFUpdate &addDeletion(RDFStatementList const &statement_template, Node const &graph = Node());
		/*!
		 * \overload
		 */
		RDFUpdate &addDeletion(RDFStatement const &statement_template, Node const &graph = Node())
		{ return addOperation(Operation::deletion(RDFStatementList() << statement_template, graph)); }
		/*!
		 * \overload
		 */
		RDFUpdate &addDeletion(RDFVariable const &subject = RDFVariable()
                , RDFVariable const &predicate = RDFVariable()
                , RDFVariable const &object = RDFVariable(), Node const &graph = Node())
		{ return addOperation(Operation::deletion(RDFStatementList() << RDFStatement(subject, predicate, object), graph)); }

		/*!
		 * Add a modification clause by given \a deletion_template and \a insertion_template into the optionally given \a graph.
		 */
		RDFUpdate &addModification(RDFStatementList const &deletion_template, RDFStatementList const &insertion_template, Node const &graph = Node());
		/*!
		 * Create a new insertion clause into optionally given \a graph, and return the \ref RDFStatement corresponding to it.
		 * \return the \ref RDFStatement corresponding to the clause
		 */
		RDFStatement newInsertion(Node const &graph = Node()) { RDFStatement ret; addInsertion(ret, graph); return ret; }
		/*!
		 * Create a new insertion clause into optionally given \a graph
		 * \return the \ref RDFStatement corresponding to the clause
		 */
		RDFStatement newDeletion(Node const &graph = Node()) { RDFStatement ret; addDeletion(ret, graph); return ret; }

		/*!
		 * Appends all clauses in the given \a update query into this update.
		 */
		RDFUpdate &appendUpdate(RDFUpdate const &update);

	};
}

//	Inline implementations section

#include "liveresource.h"

namespace SopranoLive
{
	namespace Detail
	{

			template<typename Chain_ , RDFStrategyFlags is_chained>
		struct Q_DECL_EXPORT RDFPropertyChain
			: Chain_
		{
			enum { chain_index = Chain_::Head::chain_index + 1 };

			typename Chain_::Head head_;
			RDFVariable target_;

			RDFPropertyChain(RDFVariable const &source = RDFVariable(), RDFVariable const &target = RDFVariable())
				: head_(source), target_(target) {}

			RDFVariable const &source() const { return this->head_.source(); }
			RDFVariable const &target() const { return this->target_; }
			RDFVariable const &source(int index) const { return index == chain_index ? head_.target_ : head_.source(index); }
			RDFVariable const &target(int index) const { return index == chain_index ? this->target_ : head_.target(index); }

			RDFVariable bind() { return Chain_::connect(head_.bind(), target_); }
			RDFVariable bindReverse() { Chain_::connect(head_.target_, target_); return head_.bindReverse(); }
		};

		// Chain is just a plain property
			template<typename Property_>
		struct Q_DECL_EXPORT RDFPropertyChain<Property_, 0>
			: Property_
		{
			enum { chain_index = 0 };

			RDFVariable source_, target_;
			RDFPropertyChain(RDFVariable const &source = RDFVariable(), RDFVariable const &target = RDFVariable())
				: source_(source), target_(target)
			{}

			RDFVariable const &source(int = 0) const { return this->source_; }
			RDFVariable const &target(int = 0) const { return this->target_; }

			// TODO: replace with source_.object(prop, target_);
			RDFVariable bind() { source_.template object(Property_::iri()).merge(target_); return target_;}
			// TODO: replace with target_.subject(prop, source_);
			RDFVariable bindReverse() { target_.template subject(Property_::iri()).merge(source_); return source_; }

				template<typename Predicate_>
			struct GetDomain : Predicate_ {};
		};
	}

		template<typename Resource_>
	inline RDFVariable RDFVariable::fromInstance(RDFStrategyFlags strategy)
	{
		return RDFVariable(Resource_::iri()).isOfType<typename Resource_::ResourceType>
				(false, strategy);
	}

	inline RDFFilter RDFVariable::exists() const { return inParent().isBound(); }
	inline RDFFilter RDFVariable::doesntExist() const { return inParent().isBound().not_(); }

		template<typename Property_>
	RDFVariable RDFVariable::object(RDFVariable const &object_info, RDFStrategyFlags strategy, QSharedPointer<QObject> const &parent) const
	{
		RDFProperty prop(RDFProperty::fromObjectOf<Property_>(object_info, strategy, parent));
		return bindProperty(prop);
	}
		template<typename Property_>
	RDFVariable RDFVariable::property(RDFVariable const &property_info, RDFStrategyFlags strategy, QSharedPointer<QObject> const &parent) const
	{
		RDFProperty prop(RDFProperty::fromObjectOf<Property_>(property_info, strategy, parent));
		return bindProperty(prop);
	}
		template<typename Property_>
	RDFVariable RDFVariable::subject(RDFVariable const &subject_info, RDFStrategyFlags strategy, QSharedPointer<QObject> const &parent) const
	{
		RDFProperty prop(RDFProperty::fromSubjectOf<Property_>(subject_info, strategy, parent));
		return bindProperty(prop);
	}

		template<typename Property_>
	RDFVariable RDFVariable::addDerivedObject(RDFVariable const &object_info, RDFStrategyFlags strategy
			, QSharedPointer<QObject> const &parent) const
	{
		RDFProperty prop(RDFProperty::fromObjectOf<Property_>(object_info, strategy, parent));
		return addDerivedProperty(prop);
	}

		template<typename Chain_>
	RDFVariable RDFVariable::addDerivedObject(Detail::RDFPropertyChain<Chain_> &property_chain
			, RDFVariable const &object_info, RDFStrategyFlags strategy, QSharedPointer<QObject> const &parent) const
	{
		RDFProperty prop(RDFProperty::fromObjectOf(property_chain, object_info, strategy, parent));
		return addDerivedProperty(prop);
	}

		template<typename Property_>
	RDFVariable RDFVariable::addDerivedSubject(RDFVariable const &subject_info, RDFStrategyFlags strategy
			, QSharedPointer<QObject> const &parent) const
	{
		RDFProperty prop(RDFProperty::fromSubjectOf<Property_>(subject_info, strategy, parent));
		return addDerivedProperty(prop);
	}

		template<typename Chain_>
	RDFVariable RDFVariable::addDerivedSubject(Detail::RDFPropertyChain<Chain_> &property_chain
			, RDFVariable const &subject_info, RDFStrategyFlags strategy, QSharedPointer<QObject> const &parent) const
	{
		RDFProperty prop(RDFProperty::fromSubjectOf(property_chain, subject_info, strategy, parent));
		return addDerivedProperty(prop);
	}

		template<typename Property_>
	RDFVariable RDFVariable::addUpdateObject(RDFVariable const &object_info, RDFStrategyFlags strategy
			, QSharedPointer<QObject> const &parent) const
	{
		RDFProperty prop(RDFProperty::fromObjectOf<Property_>
				(object_info, strategy | RDFStrategy::UpdateProperty, parent));
		return addDerivedProperty(prop);
	}

		template<typename Property_>
	RDFVariable RDFVariable::addUpdateSubject(RDFVariable const &subject_info, RDFStrategyFlags strategy
			, QSharedPointer<QObject> const &parent) const
	{
		RDFProperty prop(RDFProperty::fromSubjectOf<Property_>
				(subject_info, strategy | RDFStrategy::UpdateProperty, parent));
		return addDerivedProperty(prop);
	}

		template<typename Entity_, typename ValuePolicy_, typename MostDerived_>
	RDFVariable ValueOfLiveEntity<Entity_, ValuePolicy_, MostDerived_>::variable() const
	{
		return this->template evaluateVariable<MD>();
	}

		template<typename This_>
	inline RDFVariable ValueOfLiveResource_Policy::evaluateVariable() const
	{
		return md<This_>().entity_ ? md<This_>().entity_->sourceVariable() : RDFVariable(*md<This_>().value_);
	}

		template<typename Resource_> template<typename This_>
	RDFVariable LiveBagPolicy::ValuePolicy<Resource_>::evaluateVariable() const
	{
		return md<This_>().entity_ ? md<This_>().entity_->sourceVariables()[0] : RDFVariable::fromContainer(*md<This_>().value_);
	}

	namespace Detail
	{
		static inline void addRdfsResourceIfNode(RDFVariable const &, LiteralValue const &) {}
		Q_DECL_EXPORT void addRdfsResourceIfNode(RDFVariable const &var, RDFVariable const &);

			template<typename Type_>
		CppType isOfTypeHelper(void *) { return CppType(qMetaTypeId<Type_>()); }

			template<typename Type_>
		RDFVariable isOfTypeHelper(LiveResource *)
		{
			RDFVariable ret(Type_::iri());
			ret.metaSetStrategy(Type_::BaseStrategy);
			ret.metaInsertAttribute
					("SopranoLive::baseClassInfo"
					, QVariant::fromValue(AutoGen::baseClassInfo<Type_>()));
			return ret;
		}

			template< typename Type_
					, typename Resource_
					, typename NodePolicy_
					, typename MostDerived_>
		RDFVariable isOfTypeHelper(ValueOfLiveResource<Resource_, NodePolicy_, MostDerived_> *)
		{
			RDFVariable ret(Resource_::iri());
			ret.metaSetStrategy(Resource_::BaseStrategy);
			ret.metaInsertAttribute
					("SopranoLive::baseClassInfo"
					, QVariant::fromValue(AutoGen::baseClassInfo<Resource_>()));
			return ret;
		}

	}

		template<typename Type_>
	inline RDFVariable RDFVariable::isOfType(bool strict, RDFStrategyFlags strategy) const
	{
		Q_UNUSED(strict);
		Type_ *overload_selector = 0;
		return isOfType(Detail::isOfTypeHelper<Type_>(overload_selector), strategy);
	}

		template<typename Iter_>
	RDFFilter RDFVariable::isInRange(Iter_ begin, Iter_ const &end) const
	{
		RDFVariableList vars;
		if(begin != end)
		{
			Detail::addRdfsResourceIfNode(*this, *begin);
			do
				vars.push_back(RDFVariable::fromInstance(*begin));
			while(++begin != end);
		}
		return isMemberOf(vars);
	}

		template<typename Cont_>
	RDFFilter RDFVariable::isMemberOf(Cont_ const &container) const
	{
		return isInRange(container.begin(), container.end());
	}

		template<typename Iter_>
	RDFVariable RDFVariable::fromRange(Iter_ const &begin, Iter_ const &end, QString const &identifier)
	{
		RDFVariable var(identifier);
		var.isInRange(begin, end);
		return var;
	}

	RDFVariable RDFVariable::fromContainer(RDFVariableList const &set, QString const &identifier)
	{
		RDFVariable ret(identifier); ret.isMemberOf(set); return ret;
	}

		template<typename Cont_>
	RDFVariable RDFVariable::fromContainer(Cont_ const &container, QString const &identifier)
	{
		return fromRange(container.begin(), container.end(), identifier);
	}

	RDFVariable RDFVariable::fromUnion(RDFVariableList const &set, QString const &identifier)
	{
		RDFVariable ret(identifier); ret.unionMerge(set); return ret;
	}


		template<typename Function_>
	RDFFilter RDFVariable::function() const { return function(Function_::iri()); }

		template<typename Function_>
	RDFFilter RDFVariable::function(RDFVariable const &arg2) const { return function(Function_::iri(), arg2); }

		template<typename Function_>
	RDFFilter RDFVariable::function(RDFVariable const &arg2, RDFVariable const &arg3) const { return function(Function_::iri(), arg2, arg3); }

		template<typename Function_>
	RDFFilter RDFVariable::function(RDFVariableList const &args_tail) const { return function(Function_::iri(), args_tail); }

}

	template<>
SopranoLive::RDFVariable::Data *QSharedDataPointer<SopranoLive::RDFVariable::Data>::clone();
	template<>
SopranoLive::RDFPattern::Data *QSharedDataPointer<SopranoLive::RDFPattern::Data>::clone();
	template<>
SopranoLive::RDFProperty::Data *QSharedDataPointer<SopranoLive::RDFProperty::Data>::clone();
	template<>
SopranoLive::RDFSelectColumn::Data *QSharedDataPointer<SopranoLive::RDFSelectColumn::Data>::clone();
	template<>
SopranoLive::RDFQuery::Data *QSharedDataPointer<SopranoLive::RDFQuery::Data>::clone();

QT_BEGIN_NAMESPACE

Q_INLINE_TEMPLATE void qSwap(SopranoLive::RDFVariable &a, SopranoLive::RDFVariable &b)
{ a.swap(b); }

Q_INLINE_TEMPLATE void qSwap(SopranoLive::RDFProperty &a, SopranoLive::RDFProperty &b)
{ a.swap(b); }

QT_END_NAMESPACE

#endif /* SOPRANOLIVE_RDFUNBOUND_H */
